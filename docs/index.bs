<pre class='metadata'>
Title: Service Workers Nightly
Status: ED
ED: https://w3c.github.io/ServiceWorker/
TR: https://www.w3.org/TR/service-workers/
Shortname: service-workers
Level:
Editor: Alex Russell, Google, slightlyoff@chromium.org
Editor: Jungkee Song, Microsoft&sbquo; represented Samsung until April 2018, jungkee.song@microsoft.com
Editor: Jake Archibald, Google, jakearchibald@chromium.org
Editor: Marijn Kruisselbrink, Google, mek@chromium.org
Repository: w3c/ServiceWorker
Group: serviceworkers
!Tests: <a href=https://github.com/web-platform-tests/wpt/tree/master/service-workers>web-platform-tests service-workers/</a> (<a href=https://github.com/web-platform-tests/wpt/labels/service-workers>ongoing work</a>)
Status Text: This is a living document. Readers need to be aware that this specification may include unimplemented features, and details that may change. <a href="https://w3c.github.io/ServiceWorker/v1/">Service Workers 1</a> is a version that is advancing toward a W3C Recommendation.
Abstract: The core of this specification is a worker that wakes to receive events. This provides an event destination that can be used when other destinations would be inappropriate, or no other destination exists.
Abstract:
Abstract: For example, to allow the developer to decide how a page should be fetched, an event needs to dispatch potentially before any other execution contexts exist for that origin. To react to a push message, or completion of a persistent download, the context that originally registered interest may no longer exist. In these cases, the service worker is the ideal event destination.
Abstract:
Abstract: This specification also provides a [=handle fetch|fetch event=], and a [[#cache-objects|request and response store]] similar in design to the HTTP cache, which makes it easier to build offline-enabled web applications.
Markup Shorthands: css no, markdown yes
</pre>

<pre class="link-defaults">
spec: html;
    type: dfn; text: task queues; for: /
    type: element; text: link
    type: dfn; text: event loop; for: /

spec: dom;
    type: interface; text: Document

spec: fetch;
    type: dfn
        for: /; text: fetch
        text: empty
spec: infra;
    type: dfn;
        text: list
        text: queue
        for: set; text: append
        for: list; text: append
spec: webidl;
    type: dfn;
        text: resolve;
</pre>

<pre class="anchors">
spec: push; urlPrefix: https://w3c.github.io/push-api/
    type: event
        text: push; url: h-the-push-event

spec: ecma-262; urlPrefix: http://tc39.github.io/ecma262/
    type: abstract-op
        text: NormalCompletion; url: sec-normalcompletion
        text: ThrowCompletion; url: sec-throwcompletion
    type: dfn
        text: Assert; url: sec-algorithm-conventions
        text: [[Call]]; url: sec-ecmascript-function-objects-call-thisargument-argumentslist
        text: promise; url: sec-promise-objects
        text: DetachArrayBuffer; url: sec-detacharraybuffer
        url: sec-list-and-record-specification-type
            text: List
            text: Record
        text: map objects; url: sec-map-objects
        text: InitializeHostDefinedRealm; url: sec-initializehostdefinedrealm
        text: execution context; url: sec-execution-contexts
        text: abrupt completion; url: sec-completion-record-specification-type
        text: Completion; url: sec-completion-record-specification-type
        text: Module Record; url: sec-abstract-module-records
        text: Cyclic Module Record; url: sec-cyclic-module-records

spec: page-visibility; urlPrefix: https://www.w3.org/TR/page-visibility/
    type: enum; text: VisibilityState; url: VisibilityState
    type: attribute; text: visibilityState; for: Document; url: dom-document-visibilitystate

spec: html; urlPrefix: https://html.spec.whatwg.org/multipage/
    type: attribute
        urlPrefix: comms.html
            text: origin; for: MessageEvent; url: dom-messageevent-origin
            text: source; for: MessageEvent; url: dom-messageevent-source
            text: ports; for: MessageEvent; url: dom-messageevent-ports
            text: data; for: MessageEvent; url: dom-messageevent-data
    type: dfn
        urlPrefix: browsers.html
            text: ancestor origins list; for: Location; url: concept-location-ancestor-origins-list
        urlPrefix: syntax.html
            text: delay the load event; for: document; url: delay-the-load-event
        urlPrefix: origin.html
            text: creating a policy container from a fetch response
        urlPrefix: webappapis.html
            text: module map; url: module-map
            text: resolve a module specifier; url: resolve-a-module-specifier

spec: fetch; urlPrefix: https://fetch.spec.whatwg.org/
    type: dfn
        text: response; for: Response; url: concept-response-response
        text: request; for: Request; url: concept-request-request
        text: HTTP fetch; for: /; url: concept-http-fetch

spec: rfc8288; urlPrefix: https://tools.ietf.org/html/rfc8288
    type: dfn
        text: link context; url: section-3.2
        text: target attribute; url: section-3.4
        text: target attributes; url: section-3.4
        text: link target; url: section-3.1

spec: rfc7230; urlPrefix: https://tools.ietf.org/html/rfc7230
    type: dfn
        text: field-value; for: http; url: section-3.2

spec: rfc7231; urlPrefix: https://tools.ietf.org/html/rfc7231
    type: dfn
        text: Vary; url: section-7.1.4

</pre>

<pre class="biblio">
{
  "unsanctioned-tracking": {
    "href": "https://www.w3.org/2001/tag/doc/unsanctioned-tracking/",
    "title": "Unsanctioned Web Tracking",
    "date": "17 July 2015",
    "status": "Finding of the W3C TAG",
    "publisher": "W3C TAG"
  }
}
</pre>

<section>
  <h2 id="motivations">Motivations</h2>

  *This section is non-normative.*

  Web Applications traditionally assume that the network is reachable. This assumption pervades the platform. HTML documents are loaded over HTTP and traditionally fetch all of their sub-resources via subsequent HTTP requests. This places web content at a disadvantage versus other technology stacks.

  The [=/service worker=] is designed first to redress this balance by providing a Web Worker context, which can be started by a runtime when navigations are about to occur. This event-driven worker is registered against an origin and a path (or pattern), meaning it can be consulted when navigations occur to that location. Events that correspond to network requests are dispatched to the worker and the responses generated by the worker may override default network stack behavior. This puts the [=/service worker=], conceptually, between the network and a document renderer, allowing the [=/service worker=] to provide content for documents, even while offline.

  Web developers familiar with previous attempts to solve the offline problem have reported a deficit of flexibility in those solutions. As a result, the [=/service worker=] is highly procedural, providing a maximum of flexibility at the price of additional complexity for developers. Part of this complexity arises from the need to keep [=/service workers=] responsive in the face of a single-threaded execution model. As a result, APIs exposed by [=/service workers=] are almost entirely asynchronous, a pattern familiar in other JavaScript contexts but accentuated here by the need to avoid blocking document and resource loading.

  Developers using the <a lt="application cache">HTML5 Application Cache</a> have also <a href="http://alistapart.com/article/application-cache-is-a-douchebag">reported that several attributes</a> of the design contribute to <a href="http://alistapart.com/article/application-cache-is-a-douchebag#section6">unrecoverable errors</a>. A key design principle of the [=/service worker=] is that errors should *always* be recoverable. Many details of the update process of [=/service workers=] are designed to avoid these hazards.

  [=/Service workers=] are started and kept alive by their relationship to events, not documents. This design borrows heavily from developer and vendor experience with <a>Shared Workers</a> and <a href="https://developer.chrome.com/extensions/background_pages">Chrome Background Pages</a>. A key lesson from these systems is the necessity to time-limit the execution of background processing contexts, both to conserve resources and to ensure that background context loss and restart is top-of-mind for developers. As a result, [=/service workers=] bear more than a passing resemblance to <a href="https://developer.chrome.com/extensions/event_pages">Chrome Event Pages</a>, the successor to Background Pages. [=/Service workers=] may be started by user agents *without an attached document* and may be killed by the user agent at nearly any time. Conceptually, [=/service workers=] can be thought of as Shared Workers that can start, process events, and die without ever handling messages from documents. Developers are advised to keep in mind that [=/service workers=] may be started and killed many times a second.

  [=/Service workers=] are generic, event-driven, time-limited script contexts that run at an origin. These properties make them natural endpoints for a range of runtime services that may outlive the context of a particular document, e.g. handling push notifications, background data synchronization, responding to resource requests from other origins, or receiving centralized updates to expensive-to-calculate data (e.g., geolocation or gyroscope).
</section>

<section>
  <h2 id="model">Model</h2>

  <section dfn-for="service worker">
    <h3 id="service-worker-concept">Service Worker</h3>

    A <dfn export id="dfn-service-worker" for="">service worker</dfn> is a type of <a>web worker</a>. A [=/service worker=] executes in the registering [=/service worker client=]'s [=/origin=].

    A [=/service worker=] has an associated <dfn export id="dfn-state">state</dfn>, which is one of "`parsed`", "`installing`", "`installed`", "`activating`", "`activated`", and "`redundant`". It is initially "`parsed`".

    A [=/service worker=] has an associated <dfn export id="dfn-script-url">script url</dfn> (a [=/URL=]).

    A [=/service worker=] has an associated <dfn export id="dfn-type">type</dfn> which is either "<code>classic</code>" or "<code>module</code>". Unless stated otherwise, it is "<code>classic</code>".

    A [=/service worker=] has an associated <dfn export id="dfn-containing-service-worker-registration" lt="registration|containing service worker registration">containing service worker registration</dfn> (a [=/service worker registration=]), which contains itself.

    A [=/service worker=] has an associated <dfn export id="dfn-service-worker-global-object" for="service worker">global object</dfn> (a {{ServiceWorkerGlobalScope}} object or null).

    A [=/service worker=] has an associated <dfn export id="dfn-script-resource">script resource</dfn> (a <a>script</a>), which represents its own script resource. It is initially set to null.

    A <a>script resource</a> has an associated <dfn export for="script resource" id="dfn-has-ever-been-evaluated-flag">has ever been evaluated flag</dfn>. It is initially unset.

    A <a>script resource</a> has an associated <dfn export for="script resource" id="dfn-policy-container">policy container</dfn> (a [=/policy container=]). It is initially a new policy container.

    A [=/service worker=] has an associated <dfn export id="dfn-script-resource-map">script resource map</dfn> which is an <a>ordered map</a> where the keys are [=/URLs=] and the values are [=/responses=].

    A [=/service worker=] has an associated  <dfn export id="dfn-set-of-used-scripts">set of used scripts</dfn> (a [=ordered set|set=]) whose [=list/item=] is a [=/URL=]. It is initially a new [=ordered set|set=].

    Note: The [=set of used scripts=] is only used to prune unused resources from a new worker's map after installation, that were populated based on the old worker's map during the update check.

    A [=/service worker=] has an associated <dfn export id="dfn-skip-waiting-flag">skip waiting flag</dfn>. Unless stated otherwise it is unset.

    A [=/service worker=] has an associated <dfn export id="dfn-classic-scripts-imported-flag">classic scripts imported flag</dfn>. It is initially unset.

    A [=/service worker=] has an associated <dfn export id="dfn-set-of-event-types-to-handle">set of event types to handle</dfn> (a [=ordered set|set=]) whose [=list/item=] is an <a>event listener</a>'s event type. It is initially a new [=ordered set|set=].

    A [=/service worker=] has an associated <dfn export id="dfn-set-of-extended-events">set of extended events</dfn> (a [=ordered set|set=]) whose [=list/item=] is an {{ExtendableEvent}}. It is initially a new [=ordered set|set=].

    A [=/service worker=] has an associated <dfn>start status</dfn> which can be null or a [=Completion=]. It is initially null.

    A [=/service worker=] is said to be <dfn>running</dfn> if its [=event loop=] is running.

    <section>
      <h4 id="service-worker-lifetime">Lifetime</h4>

      The lifetime of a [=/service worker=] is tied to the execution lifetime of events and not references held by [=/service worker clients=] to the {{ServiceWorker}} object.

      A user agent *may* <a lt="terminate service worker">terminate</a> [=/service workers=] at any time it:

        * Has no event to handle.
        * Detects abnormal operation: such as infinite loops and tasks exceeding imposed time limits (if any) while handling the events.
    </section>

    <section>
      <h4 id="service-worker-events">Events</h4>

      The Service Workers specification defines <dfn export id="dfn-service-worker-events">service worker events</dfn> (each of which is an [=event=]) that include (see the <a href="#execution-context-events">list</a>):
          * <dfn export id="dfn-lifecycle-events">Lifecycle events</dfn>: {{install!!event}} and {{activate!!event}}.
          * <dfn export id="dfn-functional-events">Functional events</dfn>: {{fetch!!event}} and the [=events=] defined by other specifications that <a href="#extensibility">extend</a> the Service Workers specification. (See the <a href="#execution-context-events">list</a>.)
          * {{message!!event}} and {{messageerror!!event}}.
    </section>
  </section>

  <section>
    <h3 id="service-worker-timing">Service Worker Timing</h3>

    Service workers mark certain points in time that are later exposed by the <a interface lt="PerformanceNavigationTiming">navigation timing</a> API.

    A <dfn export>service worker timing info</dfn> is a [=/struct=]. It has the following [=struct/items=]:

    <section dfn-for="service worker timing info">
        : <dfn export>start time</dfn>
        :: A {{DOMHighResTimeStamp}}, initially 0.
        : <dfn export>fetch event dispatch time</dfn>
        :: A {{DOMHighResTimeStamp}}, initially 0.
    </section>
  </section>

  <section dfn-for="service worker registration">
    <h3 id="service-worker-registration-concept">Service Worker Registration</h3>

    A <dfn export id="dfn-service-worker-registration" for="">service worker registration</dfn> is a tuple of a [=service worker registration/scope url=] and a set of [=/service workers=], an <a>installing worker</a>, a <a>waiting worker</a>, and an <a>active worker</a>. A user agent *may* enable many [=/service worker registrations=] at a single origin so long as the [=service worker registration/scope url=] of the [=/service worker registration=] differs. A [=/service worker registration=] of an identical [=service worker registration/scope url=] when one already exists in the user agent causes the existing [=/service worker registration=] to be replaced.

    A [=/service worker registration=] has an associated <dfn export id="dfn-scope-url">scope url</dfn> (a [=/URL=]).

    A [=/service worker registration=] has an associated <dfn export id="dfn-installing-worker">installing worker</dfn> (a [=/service worker=] or null) whose [=service worker/state=] is "`installing`". It is initially set to null.

    A [=/service worker registration=] has an associated <dfn export id="dfn-waiting-worker">waiting worker</dfn> (a [=/service worker=] or null) whose [=service worker/state=] is "`installed`". It is initially set to null.

    A [=/service worker registration=] has an associated <dfn export id="dfn-active-worker">active worker</dfn> (a [=/service worker=] or null) whose [=service worker/state=] is either "`activating`" or "`activated`". It is initially set to null.

    A [=/service worker registration=] has an associated <dfn export id="dfn-last-update-check-time">last update check time</dfn>. It is initially set to null.

    A [=/service worker registration=] is said to be <dfn>stale</dfn> if the registration's [=last update check time=] is non-null and the time difference in seconds calculated by the current time minus the registration's [=last update check time=] is greater than 86400.

    A [=/service worker registration=] has an associated <dfn export id="dfn-update-via-cache">update via cache mode</dfn>, which is "`imports`", "`all`", or "`none`". It is initially set to "`imports`".

    A [=/service worker registration=] has one or more <dfn export id="dfn-service-worker-registration-task-queue">task queues</dfn> that back up the <a>tasks</a> from its <a>active worker</a>'s <a>event loop</a>'s corresponding [=/task queues=]. (The target task sources for this back up operation are the <a>handle fetch task source</a> and the <a>handle functional event task source</a>.) The user agent dumps the <a>active worker</a>'s <a>tasks</a> to the [=/service worker registration=]'s [=service worker registration/task queues=] when the <a>active worker</a> is <a lt="terminate service worker">terminated</a> and <a lt="queue a task">re-queues those tasks</a> to the <a>active worker</a>'s <a>event loop</a>'s corresponding [=/task queues=] when the <a>active worker</a> spins off. Unlike the [=/task queues=] owned by <a>event loops</a>, the [=/service worker registration=]'s [=service worker registration/task queues=] are not processed by any <a>event loops</a> in and of itself.

    A [=/service worker registration=] has an associated <dfn export>{{NavigationPreloadManager}}</dfn> object.

    A [=/service worker registration=] has an associated <dfn export>navigation preload enabled flag</dfn>. It is initially unset.

    A [=/service worker registration=] has an associated <dfn export>navigation preload header value</dfn>, which is a [=byte sequence=]. It is initially set to \`<code>true</code>\`.

    A [=/service worker registration=] is said to be <dfn export id="dfn-service-worker-registration-unregistered">unregistered</dfn> if [=scope to registration map=][this [=/service worker registration=]'s [=service worker registration/scope url=]] is not this [=/service worker registration=].

    <section>
      <h4 id="service-worker-registration-lifetime">Lifetime</h4>

      A user agent *must* persistently keep a list of <a>registered</a> [=/service worker registrations=] unless otherwise they are explicitly <a>unregistered</a>. A user agent has a <a>scope to registration map</a> that stores the entries of the tuple of [=/service worker registration=]'s [=service worker registration/scope url=], [=URL serializer|serialized=], and the corresponding [=/service worker registration=]. The lifetime of [=/service worker registrations=] is beyond that of the {{ServiceWorkerRegistration}} objects which represent them within the lifetime of their corresponding [=/service worker clients=].
    </section>
  </section>

  <section dfn-for="service worker client">
    <h3 id="service-worker-client-concept">Service Worker Client</h3>

    A <dfn export id="dfn-service-worker-client" for="">service worker client</dfn> is an [=/environment=].

    A [=/service worker client=] has an associated <dfn export>discarded flag</dfn>. It is initially unset.

    Each [=/service worker client=] has the following [=environment discarding steps=]:
        1. Set |client|'s [=discarded flag=].

    Note: Implementations can discard clients whose [=discarded flag=] is set.

    A [=/service worker client=] has an algorithm defined as the <dfn export for="service worker client">origin</dfn> that returns the [=/service worker client=]'s [=environment settings object/origin=] if the [=/service worker client=] is an [=environment settings object=], and the [=/service worker client=]'s <a>creation URL</a>'s [=url/origin=] otherwise.

    A <dfn export id="dfn-window-client">window client</dfn> is a [=/service worker client=] whose [=environment settings object/global object=] is a {{Window}} object.

    A <dfn export id="dfn-dedicatedworker-client">dedicated worker client</dfn> is a [=/service worker client=] whose [=environment settings object/global object=] is a {{DedicatedWorkerGlobalScope}} object.

    A <dfn export id="dfn-sharedworker-client">shared worker client</dfn> is a [=/service worker client=] whose [=environment settings object/global object=] is a {{SharedWorkerGlobalScope}} object.

    A <dfn export id="dfn-worker-client">worker client</dfn> is either a <a>dedicated worker client</a> or a <a>shared worker client</a>.
  </section>

  <section>
    <h3 id="control-and-use">Control and Use</h3>

    A [=/service worker client=] has an [=active service worker=] that serves its own loading and its subresources. When a [=/service worker client=] has a non-null [=active service worker=], it is said to be <dfn id="dfn-control" lt="controlling|controls|controlled">controlled</dfn> by that [=active service worker=]. When a [=/service worker client=] is [=controlled=] by a [=/service worker=], it is said that the [=/service worker client=] is <dfn id="dfn-use" lt="using|uses|used">using</dfn> the [=/service worker=]’s [=containing service worker registration=].
    A [=/service worker client=]'s [=active service worker=] is determined as explained in the following subsections.

    *The rest of the section is non-normative.*

    Issue: The behavior in this section is not fully specified yet and will be specified in [HTML Standard](https://html.spec.whatwg.org). The work is tracked by the [issue](https://github.com/w3c/ServiceWorker/issues/765) and the [pull request](https://github.com/whatwg/html/pull/2809).

    <section>
      <h4 id="control-and-use-window-client">The window client case</h4>

      A [=window client=] is [created](https://html.spec.whatwg.org/#set-up-a-window-environment-settings-object) when a [=/browsing context=] is [created](https://html.spec.whatwg.org/#creating-a-new-browsing-context) and when it [=navigates=].

      When a [=window client=] is [created](https://html.spec.whatwg.org/#set-up-a-window-environment-settings-object) in the process of a [=/browsing context=] [creation](https://html.spec.whatwg.org/#creating-a-new-browsing-context):

      If the [=/browsing context=]'s initial [=active document=]'s [=/origin=] is an [=opaque origin=], the [=window client=]'s [=active service worker=] is set to null.
      Otherwise, it is set to the creator [=document=]'s [=/service worker client=]'s [=active service worker=].

      When a [=window client=] is [created](https://html.spec.whatwg.org/#set-up-a-window-environment-settings-object) in the process of the [=/browsing context=]'s [=navigate|navigation=]:

      If the [=fetch=] is routed through [=/HTTP fetch=], the [=window client=]'s [=active service worker=] is set to the result of the <a lt="Match Service Worker Registration">service worker registration matching</a>.
      Otherwise, if the created [=document=]'s [=/origin=] is an [=opaque origin=] or not the [=same origin|same=] as its creator [=document=]'s [=/origin=], the [=window client=]'s [=active service worker=] is set to null.
      Otherwise, it is set to the creator [=document=]'s [=/service worker client=]'s [=active service worker=].

      Note: For an initial [=navigate|navigation=] with [=replacement enabled=], the initial [=window client=] that was [created](https://html.spec.whatwg.org/#set-up-a-window-environment-settings-object) when the [=/browsing context=] was [created](https://html.spec.whatwg.org/#creating-a-new-browsing-context) is reused, but the [=active service worker=] is determined by the same behavior as above.

      Note: <a element-attr for=iframe lt=sandbox>Sandboxed</a> <{iframe}>s without the sandboxing directives, `allow-same-origin` and `allow-scripts`, result in having the [=active service worker=] value of null as their [=/origin=] is an [=opaque origin=].
    </section>

    <section>
      <h4 id="control-and-use-worker-client">The worker client case</h4>

      A [=worker client=] is <a href="https://html.spec.whatwg.org/#set-up-a-worker-environment-settings-object">created</a> when the user agent [=run a worker|runs a worker=].

      When the [=worker client=] is created:

      When the [=fetch=] is routed through [=/HTTP fetch=], the [=worker client=]'s [=active service worker=] is set to the result of the <a lt="Match Service Worker Registration">service worker registration matching</a>.
      Otherwise, if the [=worker client=]'s [=service worker client/origin=] is an [=opaque origin=], or the [=/request=]'s [=request/URL=] is a [=blob URL=] and the [=worker client=]'s [=service worker client/origin=] is not the [=same origin|same=] as the [=/origin=] of the last [=set/item=] in the [=worker client=]'s [=/global object=]'s [=owner set=], the [=worker client=]'s [=active service worker=] is set to null.
      Otherwise, it is set to the [=active service worker=] of the [=environment settings object=] of the last [=set/item=] in the [=worker client=]'s [=/global object=]'s [=owner set=].
    </section>

    Note: [=Window clients=] and [=worker clients=] with a [data: URL](https://tools.ietf.org/html/rfc2397#section-2) result in having the [=active service worker=] value of null as their [=/origin=] is an [=opaque origin=]. [=Window clients=] and [=worker clients=] with a [=blob URL=] can inherit the [=active service worker=] of their creator [=document=] or owner, but if the [=/request=]'s [=request/origin=] is not the [=same origin|same=] as the [=/origin=] of their creator [=document=] or owner, the [=active service worker=] is set to null.
  </section>

  <section>
    <h3 id="task-sources">Task Sources</h3>

    The following additional <a>task sources</a> are used by [=/service workers=].

      : The <dfn export id="dfn-handle-fetch-task-source">handle fetch task source</dfn>
      :: This <a>task source</a> is used for <a>dispatching</a> {{fetch!!event}} events to [=/service workers=].
      : The <dfn export id="dfn-handle-functional-event-task-source">handle functional event task source</dfn>
      :: This <a>task source</a> is used for features that <a>dispatch</a> other <a>functional events</a>, e.g. {{push!!event}} events, to [=/service workers=].

        Note: A user agent may use a separate task source for each functional event type in order to avoid a head-of-line blocking phenomenon for certain functional events.
  </section>

  <section>
    <h3 id="user-agent-shutdown">User Agent Shutdown</h3>

    A user agent *must* maintain the state of its stored [=/service worker registrations=] across restarts with the following rules:

      * An <a>installing worker</a> does not persist but is discarded. If the <a>installing worker</a> was the only [=/service worker=] for the [=/service worker registration=], the [=/service worker registration=] is discarded.
      * A <a>waiting worker</a> promotes to an <a>active worker</a>.

    To attain this, the user agent *must* invoke <a>Handle User Agent Shutdown</a> when it terminates.
  </section>
</section>
<section>
  <h2 id="document-context">Client Context</h2>

  <div class="example">
    Bootstrapping with a service worker:

    <pre highlight="js">
      // scope defaults to the path the script sits in
      // "/" in this example
      navigator.serviceWorker.register("/serviceworker.js").then(registration => {
        console.log("success!");
        if (registration.installing) {
          registration.installing.postMessage("Howdy from your installing page.");
        }
      }, err => {
        console.error("Installing the worker failed!", err);
      });
    </pre>
  </div>

  <section>
    <h3 id="serviceworker-interface">{{ServiceWorker}}</h3>

    <pre class="idl">
      [SecureContext, Exposed=(Window,Worker)]
      interface ServiceWorker : EventTarget {
        readonly attribute USVString scriptURL;
        readonly attribute ServiceWorkerState state;
        undefined postMessage(any message, sequence&lt;object&gt; transfer);
        undefined postMessage(any message, optional StructuredSerializeOptions options = {});

        // event
        attribute EventHandler onstatechange;
      };
      ServiceWorker includes AbstractWorker;

      enum ServiceWorkerState {
        "parsed",
        "installing",
        "installed",
        "activating",
        "activated",
        "redundant"
      };
    </pre>

    A {{ServiceWorker}} object represents a [=/service worker=]. Each {{ServiceWorker}} object is associated with a [=/service worker=]. Multiple separate objects implementing the {{ServiceWorker}} interface across documents and workers can all be associated with the same [=/service worker=] simultaneously.

    A {{ServiceWorker}} object has an associated {{ServiceWorkerState}} object which is itself associated with [=/service worker=]'s <a>state</a>.

    <section>
      <h4 id="service-worker-creation">Getting {{ServiceWorker}} instances</h4>

      An [=environment settings object=] has a <dfn for="environment settings object">service worker object map</dfn>, a [=/map=] where the [=map/keys=] are [=/service workers=] and the [=map/values=] are {{ServiceWorker}} objects.

      <section algorithm="service-worker-creation-algorithm">
        To <dfn lt="get the service worker object|getting the service worker object">get the service worker object</dfn> representing |serviceWorker| (a [=/service worker=]) in |environment| (an [=environment settings object=]), run these steps:

          1. Let |objectMap| be |environment|'s [=environment settings object/service worker object map=].
          1. If |objectMap|[|serviceWorker|] does not [=map/exist=], then:
            1. Let |serviceWorkerObj| be a new {{ServiceWorker}} in |environment|'s [=environment settings object/Realm=], and associate it with |serviceWorker|.
            1. Set |serviceWorkerObj|'s {{ServiceWorker/state}} to |serviceWorker|'s [=service worker/state=].
            1. Set |objectMap|[|serviceWorker|] to |serviceWorkerObj|.
          1. Return |objectMap|[|serviceWorker|].
      </section>
    </section>

    <section>
      <h4 id="service-worker-url">{{ServiceWorker/scriptURL}}</h4>

      The <dfn attribute for="ServiceWorker"><code>scriptURL</code></dfn> getter steps are to return the [=/service worker=]'s <a lt="URL serializer">serialized</a> [=service worker/script url=].

      <div class="example">
        For example, consider a document created by a navigation to <code>https://example.com/app.html</code> which <a lt="Match Service Worker Registration">matches</a> via the following registration call which has been previously executed:

        <pre highlight="js">
          // Script on the page https://example.com/app.html
          navigator.serviceWorker.register("/service_worker.js");
        </pre>

        The value of <code>navigator.serviceWorker.controller.scriptURL</code> will be "<code>https://example.com/service_worker.js</code>".
      </div>
    </section>

    <section>
      <h4 id="service-worker-state">{{ServiceWorker/state}}</h4>

      The <dfn attribute for="ServiceWorker"><code>state</code></dfn> attribute *must* return the value (in {{ServiceWorkerState}} enumeration) to which it was last set.
    </section>

    <section algorithm="service-worker-postmessage">
      <h4 id="service-worker-postmessage">{{ServiceWorker/postMessage(message, transfer)}}</h4>

      The <dfn method for="ServiceWorker"><code>postMessage(|message|, |transfer|)</code></dfn> method steps are:

        1. Let |options| be «[ "transfer" → |transfer| ]».
        1. Invoke {{ServiceWorker/postMessage(message, options)}} with |message| and |options| as the arguments.
    </section>

    <section algorithm="service-worker-postmessage-options">
      <h4 id="service-worker-postmessage-options">{{ServiceWorker/postMessage(message, options)}}</h4>

      The <dfn method for="ServiceWorker"><code>postMessage(|message|, |options|)</code></dfn> method steps are:

        1. Let |serviceWorker| be the [=/service worker=] represented by [=this=].
        1. Let |incumbentSettings| be the [=incumbent settings object=].
        1. Let |incumbentGlobal| be |incumbentSettings|'s [=environment settings object/global object=].
        1. Let |serializeWithTransferResult| be <a abstract-op>StructuredSerializeWithTransfer</a>(|message|, |options|["{{StructuredSerializeOptions/transfer}}"]). Rethrow any exceptions.
        1. If the result of running the [=Should Skip Event=] algorithm with "message" and |serviceWorker| is true, then return.
        1. Run these substeps [=in parallel=]:
            1. If the result of running the [=Run Service Worker=] algorithm with |serviceWorker| is *failure*, then return.
            1. [=Queue a task=] on the [=DOM manipulation task source=] to run the following steps:
                1. Let |source| be determined by switching on the type of |incumbentGlobal|:
                    <dl class="switch">
                        <dt>{{ServiceWorkerGlobalScope}}</dt>
                        <dd>The result of [=getting the service worker object=] that represents |incumbentGlobal|'s [=ServiceWorkerGlobalScope/service worker=] in the [=relevant settings object=] of |serviceWorker|'s [=service worker/global object=].</dd>

                        <dt>{{Window}}</dt>
                        <dd>a new {{WindowClient}} object that represents |incumbentGlobal|'s [=relevant settings object=].</dd>

                        <dt>Otherwise</dt>
                        <dd>a new {{Client}} object that represents |incumbentGlobal|'s associated worker
                    </dd>
                1. Let |origin| be the [=serialization of an origin|serialization=] of |incumbentSettings|'s [=environment settings object/origin=].
                1. Let |destination| be the {{ServiceWorkerGlobalScope}} object associated with |serviceWorker|.
                1.  Let |deserializeRecord| be <a abstract-op>StructuredDeserializeWithTransfer</a>(|serializeWithTransferResult|, |destination|'s [=global object/Realm=]).

                    If this throws an exception, let |e| be the result of [=creating an event=] named {{messageerror!!event}}, using {{ExtendableMessageEvent}}, with the {{ExtendableMessageEvent/origin}} attribute initialized to |origin| and the {{ExtendableMessageEvent/source}} attribute initialized to |source|.
                1. Else:
                    1. Let |messageClone| be |deserializeRecord|.\[[Deserialized]].
                    1. Let |newPorts| be a new [=frozen array type|frozen array=] consisting of all {{MessagePort}} objects in |deserializeRecord|.\[[TransferredValues]], if any, maintaining their relative order.
                    1. Let |e| be the result of [=creating an event=] named {{message!!event}}, using {{ExtendableMessageEvent}}, with the {{ExtendableMessageEvent/origin}} attribute initialized to |origin|, the {{ExtendableMessageEvent/source}} attribute initialized to |source|, the {{ExtendableMessageEvent/data}} attribute initialized to |messageClone|, and the {{ExtendableMessageEvent/ports}} attribute initialized to |newPorts|.
                1. [=Dispatch=] |e| at |destination|.
                1. Invoke [=Update Service Worker Extended Events Set=] with |serviceWorker| and |e|.
    </section>

    <section>
      <h4 id="service-worker-event-handler">Event handler</h4>

      The following is the <a>event handler</a> (and its corresponding <a>event handler event type</a>) that *must* be supported, as <a>event handler IDL attributes</a>, by all objects implementing {{ServiceWorker}} interface:

      <table class="data">
        <thead>
          <tr>
            <th><a>event handler</a></th>
            <th><a>event handler event type</a></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><dfn attribute for="ServiceWorker"><code>onstatechange</code></dfn></td>
            <td>{{ServiceWorker/statechange}}</td>
          </tr>
        </tbody>
      </table>
    </section>
  </section>

  <section>
    <h3 id="serviceworkerregistration-interface">{{ServiceWorkerRegistration}}</h3>

    <pre class="idl">
      [SecureContext, Exposed=(Window,Worker)]
      interface ServiceWorkerRegistration : EventTarget {
        readonly attribute ServiceWorker? installing;
        readonly attribute ServiceWorker? waiting;
        readonly attribute ServiceWorker? active;
        [SameObject] readonly attribute NavigationPreloadManager navigationPreload;

        readonly attribute USVString scope;
        readonly attribute ServiceWorkerUpdateViaCache updateViaCache;

        [NewObject] Promise&lt;undefined&gt; update();
        [NewObject] Promise&lt;boolean&gt; unregister();

        // event
        attribute EventHandler onupdatefound;
      };

      enum ServiceWorkerUpdateViaCache {
        "imports",
        "all",
        "none"
      };
    </pre>

    A {{ServiceWorkerRegistration}} has a <dfn export for="ServiceWorkerRegistration">service worker registration</dfn> (a [=/service worker registration=]).

    <section>
      <h4 id="service-worker-registration-creation">Getting {{ServiceWorkerRegistration}} instances</h4>

      An [=environment settings object=] has a <dfn for="environment settings object">service worker registration object map</dfn>, a [=/map=] where the [=map/keys=] are [=/service worker registrations=] and the [=map/values=] are {{ServiceWorkerRegistration}} objects.

      <section algorithm="service-worker-registration-creation-algorithm">
        To <dfn lt="get the service worker registration object|getting the service worker registration object">get the service worker registration object</dfn> representing |registration| (a [=/service worker registration=]) in |environment| (an [=environment settings object=]), run these steps:

          1. Let |objectMap| be |environment|'s [=environment settings object/service worker registration object map=].
          1. If |objectMap|[|registration|] does not [=map/exist=], then:
            1. Let |registrationObject| be a new {{ServiceWorkerRegistration}} in |environment|'s [=environment settings object/Realm=].
            1. Set |registrationObject|'s [=ServiceWorkerRegistration/service worker registration=] to |registration|.
            1. Set |registrationObject|'s {{ServiceWorkerRegistration/installing}} attribute to null.
            1. Set |registrationObject|'s {{ServiceWorkerRegistration/waiting}} attribute to null.
            1. Set |registrationObject|'s {{ServiceWorkerRegistration/active}} attribute to null.
            1. If |registration|'s [=service worker registration/installing worker=] is not null, then set |registrationObject|'s {{ServiceWorkerRegistration/installing}} attribute to the result of [=getting the service worker object=] that represents |registration|'s [=service worker registration/installing worker=] in |environment|.
            1. If |registration|'s [=service worker registration/waiting worker=] is not null, then set |registrationObject|'s {{ServiceWorkerRegistration/waiting}} attribute to the result of [=getting the service worker object=] that represents |registration|'s [=service worker registration/waiting worker=] in |environment|.
            1. If |registration|'s [=service worker registration/active worker=] is not null, then set |registrationObject|'s {{ServiceWorkerRegistration/active}} attribute to the result of [=getting the service worker object=] that represents |registration|'s [=service worker registration/active worker=] in |environment|.
            1. Set |objectMap|[|registration|] to |registrationObject|.
          1. Return |objectMap|[|registration|].
      </section>
    </section>

    <section algorithm="navigator-service-worker-installing">
      <h4 id="navigator-service-worker-installing">{{ServiceWorkerRegistration/installing}}</h4>

      <dfn attribute for="ServiceWorkerRegistration"><code>installing</code></dfn> attribute *must* return the value to which it was last set.

      Note: Within a [=environment settings object/Realm=], there is only one {{ServiceWorker}} object per associated [=/service worker=].
    </section>

    <section algorithm="navigator-service-worker-waiting">
      <h4 id="navigator-service-worker-waiting">{{ServiceWorkerRegistration/waiting}}</h4>

      <dfn attribute for="ServiceWorkerRegistration"><code>waiting</code></dfn> attribute *must* return the value to which it was last set.

      Note: Within a [=environment settings object/Realm=], there is only one {{ServiceWorker}} object per associated [=/service worker=].
    </section>

    <section algorithm="navigator-service-worker-active">
      <h4 id="navigator-service-worker-active">{{ServiceWorkerRegistration/active}}</h4>

      <dfn attribute for="ServiceWorkerRegistration"><code>active</code></dfn> attribute *must* return the value to which it was last set.

      Note: Within a [=environment settings object/Realm=], there is only one {{ServiceWorker}} object per associated [=/service worker=].
    </section>

    <section algorithm="service-worker-registration-navigationpreload">
      <h4 id="service-worker-registration-navigationpreload">{{ServiceWorkerRegistration/navigationPreload}}</h4>

      The <dfn attribute for="ServiceWorkerRegistration"><code>navigationPreload</code></dfn> getter steps are to return the [=ServiceWorkerRegistration/service worker registration=]'s {{NavigationPreloadManager}} object.
    </section>

    <section algorithm="service-worker-registration-scope">
      <h4 id="service-worker-registration-scope">{{ServiceWorkerRegistration/scope}}</h4>

      The <dfn attribute for="ServiceWorkerRegistration"><code>scope</code></dfn> getter steps are to return the [=ServiceWorkerRegistration/service worker registration=]'s <a lt="URL serializer">serialized</a> [=service worker registration/scope url=].

      <div class="example">
        In the example in [[#service-worker-url]], the value of <code>registration.scope</code>, obtained from <code>navigator.serviceWorker.ready.then(registration => console.log(registration.scope))</code> for example, will be "<code>https://example.com/</code>".
      </div>
    </section>

    <section algorithm="service-worker-registration-updateviacache">
      <h4 id="service-worker-registration-updateviacache">{{ServiceWorkerRegistration/updateViaCache}}</h4>

      The <dfn attribute for="ServiceWorkerRegistration"><code>updateViaCache</code></dfn> getter steps are to return the [=ServiceWorkerRegistration/service worker registration=]'s [=service worker registration/update via cache mode=].
    </section>

    <section algorithm="service-worker-registration-update">
      <h4 id="service-worker-registration-update">{{ServiceWorkerRegistration/update()}}</h4>

      The <dfn method for="ServiceWorkerRegistration"><code>update()</code></dfn> method steps are:

        1. Let |registration| be the [=ServiceWorkerRegistration/service worker registration=].
        1. Let |newestWorker| be the result of running <a>Get Newest Worker</a> algorithm passing |registration| as its argument.
        1. If |newestWorker| is null, return [=a promise rejected with=] an "{{InvalidStateError}}" {{DOMException}} and abort these steps.
        1. If [=this=]'s [=relevant global object=] |globalObject| is a {{ServiceWorkerGlobalScope}} object, and |globalObject|'s associated [=ServiceWorkerGlobalScope/service worker=]'s <a>state</a> is "`installing`", return [=a promise rejected with=] an "{{InvalidStateError}}" {{DOMException}} and abort these steps.
        1. Let |promise| be a <a>promise</a>.
        1. Let |job| be the result of running <a>Create Job</a> with *update*, |registration|'s [=service worker registration/scope url=], |newestWorker|'s [=service worker/script url=], |promise|, and [=this=]'s <a>relevant settings object</a>.
        1. Set |job|'s <a>worker type</a> to |newestWorker|'s [=service worker/type=].
        1. Invoke <a>Schedule Job</a> with |job|.
        1. Return |promise|.
    </section>

    <section algorithm="navigator-service-worker-unregister">
      <h4 id="navigator-service-worker-unregister">{{ServiceWorkerRegistration/unregister()}}</h4>

      Note: The {{ServiceWorkerRegistration/unregister()}} method unregisters the [=/service worker registration=]. It is important to note that the currently [=controlled=] [=/service worker client=]'s [=active service worker=]'s [=containing service worker registration=] is effective until all the [=/service worker clients=] (including itself) using this [=/service worker registration=] unload. That is, the {{ServiceWorkerRegistration/unregister()}} method only affects subsequent [=navigate|navigations=].

      The <dfn method for="ServiceWorkerRegistration"><code>unregister()</code></dfn> method steps are:

        1. Let |promise| be [=a new promise=].
        1. Let |job| be the result of running [=Create Job=] with *unregister*, the [=service worker registration/scope url=] of the [=ServiceWorkerRegistration/service worker registration=], null, |promise|, and [=this=]'s <a>relevant settings object</a>.
        1. Invoke <a>Schedule Job</a> with |job|.
        1. Return |promise|.
    </section>

    <section>
      <h4 id="service-worker-registration-event-handler">Event handler</h4>

      The following is the <a>event handler</a> (and its corresponding <a>event handler event type</a>) that *must* be supported, as <a>event handler IDL attributes</a>, by all objects implementing {{ServiceWorkerRegistration}} interface:

      <table class="data">
        <thead>
          <tr>
            <th><a>event handler</a></th>
            <th><a>event handler event type</a></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><dfn attribute for="ServiceWorkerRegistration"><code>onupdatefound</code></dfn></td>
            <td>{{updatefound!!event}}</td>
          </tr>
        </tbody>
      </table>
    </section>
  </section>

  <section>
    <h3 id="navigator-serviceworker">{{Navigator/serviceWorker|navigator.serviceWorker}}</h3>

    <pre class="idl">
      partial interface Navigator {
        [SecureContext, SameObject] readonly attribute ServiceWorkerContainer serviceWorker;
      };

      partial interface WorkerNavigator {
        [SecureContext, SameObject] readonly attribute ServiceWorkerContainer serviceWorker;
      };
    </pre>

    The <dfn attribute for="Navigator,WorkerNavigator" id="navigator-service-worker-attribute"><code>serviceWorker</code></dfn> getter steps are to return the {{ServiceWorkerContainer}} object that is associated with [=this=].
  </section>

  <section>
    <h3 id="serviceworkercontainer-interface">{{ServiceWorkerContainer}}</h3>

    <pre class="idl">
      [SecureContext, Exposed=(Window,Worker)]
      interface ServiceWorkerContainer : EventTarget {
        readonly attribute ServiceWorker? controller;
        readonly attribute Promise&lt;ServiceWorkerRegistration&gt; ready;

        [NewObject] Promise&lt;ServiceWorkerRegistration&gt; register(USVString scriptURL, optional RegistrationOptions options = {});

        [NewObject] Promise&lt;(ServiceWorkerRegistration or undefined)&gt; getRegistration(optional USVString clientURL = "");
        [NewObject] Promise&lt;FrozenArray&lt;ServiceWorkerRegistration&gt;&gt; getRegistrations();

        undefined startMessages();


        // events
        attribute EventHandler oncontrollerchange;
        attribute EventHandler onmessage; // event.source of message events is ServiceWorker object
        attribute EventHandler onmessageerror;
      };
    </pre>
    <pre class="idl" id="registration-option-list-dictionary">
      dictionary RegistrationOptions {
        USVString scope;
        WorkerType type = "classic";
        ServiceWorkerUpdateViaCache updateViaCache = "imports";
      };
    </pre>

    The user agent *must* create a {{ServiceWorkerContainer}} object when a {{Navigator}} object or a {{WorkerNavigator}} object is created and associate it with that object.

    A {{ServiceWorkerContainer}} provides capabilities to register, unregister, and update the [=/service worker registrations=], and provides access to the state of the [=/service worker registrations=] and their associated [=/service workers=].

    A {{ServiceWorkerContainer}} has an associated <dfn for="ServiceWorkerContainer">service worker client</dfn>, which is a [=/service worker client=] whose [=environment settings object/global object=] is associated with the {{Navigator}} object or the {{WorkerNavigator}} object that the {{ServiceWorkerContainer}} is retrieved from.

    A {{ServiceWorkerContainer}} object has an associated <dfn for="ServiceWorkerContainer">ready promise</dfn> (a [=promise=] or null). It is initially null.

    A {{ServiceWorkerContainer}} object has a <a>task source</a> called the <dfn export id="dfn-client-message-queue" for="ServiceWorkerContainer">client message queue</dfn>, initially empty. A [=ServiceWorkerContainer/client message queue=] can be enabled or disabled, and is initially disabled. When a {{ServiceWorkerContainer}} object's [=ServiceWorkerContainer/client message queue=] is enabled, the <a>event loop</a> *must* use it as one of its <a>task sources</a>. When the {{ServiceWorkerContainer}} object's <a>relevant global object</a> is a {{Window}} object, all <a>tasks</a> <a lt="queue a task">queued</a> on its [=ServiceWorkerContainer/client message queue=] *must* be associated with its <a>relevant settings object</a>'s <a>responsible document</a>.

    <section algorithm="navigator-service-worker-controller">
      <h4 id="navigator-service-worker-controller">{{ServiceWorkerContainer/controller}}</h4>

      <dfn attribute for="ServiceWorkerContainer"><code>controller</code></dfn> attribute *must* run these steps:

        1. Let |client| be [=this=]'s [=ServiceWorkerContainer/service worker client=].
        1. If |client|'s [=active service worker=] is null, then return null.
        1. Return the result of [=getting the service worker object=] that represents |client|'s [=active service worker=] in [=this=]'s [=relevant settings object=].

      Note: {{ServiceWorkerContainer/controller|navigator.serviceWorker.controller}} returns <code>null</code> if the request is a force refresh (shift+refresh).
    </section>

    <section algorithm="navigator-service-worker-ready">
      <h4 id="navigator-service-worker-ready">{{ServiceWorkerContainer/ready}}</h4>

      <dfn attribute for="ServiceWorkerContainer"><code>ready</code></dfn> attribute *must* run these steps:

        1. If [=this=]'s [=ServiceWorkerContainer/ready promise=] is null, then set [=this=]'s [=ServiceWorkerContainer/ready promise=] to [=a new promise=].
        1. Let |readyPromise| be [=this=]'s [=ServiceWorkerContainer/ready promise=].
        1. If |readyPromise| is pending, run the following substeps [=in parallel=]:
            1. Let |registration| be the result of running [=Match Service Worker Registration=] with [=this=]'s [=ServiceWorkerContainer/service worker client=]'s [=creation URL=].
            1. If |registration| is not null, and |registration|'s [=active worker=] is not null, [=queue a task=] on |readyPromise|'s [=relevant settings object=]'s [=responsible event loop=], using the [=DOM manipulation task source=], to resolve |readyPromise| with the result of [=getting the service worker registration object=] that represents |registration| in |readyPromise|'s [=relevant settings object=].
        1. Return |readyPromise|.

      Note: The returned [=ServiceWorkerContainer/ready promise=] will never reject. If it does not resolve in this algorithm, it will eventually resolve when a matching [=/service worker registration=] is registered and its [=active worker=] is set. (See the relevant [Activate algorithm step](#activate-resolve-ready-step).)
    </section>

    <section algorithm="navigator-service-worker-register">
      <h4 id="navigator-service-worker-register">{{ServiceWorkerContainer/register(scriptURL, options)}}</h4>

      Note: The {{ServiceWorkerContainer/register(scriptURL, options)}} method creates or updates a [=/service worker registration=] for the given [=service worker registration/scope url=]. If successful, a [=/service worker registration=] ties the provided |scriptURL| to a [=service worker registration/scope url=], which is subsequently used for <a lt="handle fetch">navigation matching</a>.

      The <dfn method for="ServiceWorkerContainer"><code>register(|scriptURL|, |options|)</code></dfn> method steps are:

        1. Let |p| be a <a>promise</a>.
        1. Let |client| be [=this=]'s [=ServiceWorkerContainer/service worker client=].
        1. Let |scriptURL| be the result of <a lt="URL parser">parsing</a> |scriptURL| with [=this=]'s <a>relevant settings object</a>'s <a>API base URL</a>.
        1. Let |scopeURL| be null.
        1. If |options|["{{RegistrationOptions/scope}}"] [=map/exists=], set |scopeURL| to the result of <a lt="URL parser">parsing</a> |options|["{{RegistrationOptions/scope}}"] with [=this=]'s <a>relevant settings object</a>'s <a>API base URL</a>.
        1. Invoke [=Start Register=] with |scopeURL|, |scriptURL|, |p|, |client|, |client|'s <a>creation URL</a>, |options|["{{RegistrationOptions/type}}"], and |options|["{{RegistrationOptions/updateViaCache}}"].
        1. Return |p|.
    </section>

    <section algorithm="navigator-service-worker-getRegistration">
      <h4 id="navigator-service-worker-getRegistration">{{ServiceWorkerContainer/getRegistration(clientURL)}}</h4>

      <dfn method for="ServiceWorkerContainer"><code>getRegistration(|clientURL|)</code></dfn> method steps are:

        1. Let |client| be [=this=]'s [=ServiceWorkerContainer/service worker client=].
        1. Let |clientURL| be the result of <a lt="URL parser">parsing</a> |clientURL| with [=this=]'s <a>relevant settings object</a>'s <a>API base URL</a>.
        1. If |clientURL| is failure, return a <a>promise</a> rejected with a <code>TypeError</code>.
        1. Set |clientURL|'s [=url/fragment=] to null.
        1. If the [=environment settings object/origin=] of |clientURL| is not |client|'s [=environment settings object/origin=], return a |promise| rejected with a "{{SecurityError}}" {{DOMException}}.
        1. Let |promise| be a new <a>promise</a>.
        1. Run the following substeps <a>in parallel</a>:
            1. Let |registration| be the result of running <a>Match Service Worker Registration</a> algorithm with |clientURL| as its argument.
            1. If |registration| is null, resolve |promise| with undefined and abort these steps.
            1. Resolve |promise| with the result of [=getting the service worker registration object=] that represents |registration| in |promise|'s [=relevant settings object=].
        1. Return |promise|.
    </section>

    <section algorithm="navigator-service-worker-getRegistrations">
      <h4 id="navigator-service-worker-getRegistrations">{{ServiceWorkerContainer/getRegistrations()}}</h4>

      <dfn method for="ServiceWorkerContainer"><code>getRegistrations()</code></dfn> method steps are:

        1. Let |client| be [=this=]'s [=ServiceWorkerContainer/service worker client=].
        1. Let |promise| be [=a new promise=].
        1. Run the following steps [=in parallel=]:
            1. Let |registrations| be a new [=list=].
            1. [=map/For each=] |scope| → |registration| of [=scope to registration map=]:
                1. If the [=url/origin=] of the result of [=URL parser|parsing=] |scope| is the [=same origin|same=] as |client|'s [=environment settings object/origin=], then [=append=] |registration| to |registrations|.
            1. [=Queue a task=] on |promise|'s [=relevant settings object=]'s [=responsible event loop=], using the [=DOM manipulation task source=], to run the following steps:
                1. Let |registrationObjects| be a new [=list=].
                1. [=list/For each=] |registration| of |registrations|:
                    1. Let |registrationObj| be the result of [=getting the service worker registration object=] that represents |registration| in |promise|'s [=relevant settings object=].
                    1. [=list/Append=] |registrationObj| to |registrationObjects|.
                1. Resolve |promise| with [=create a frozen array|a new frozen array of=] |registrationObjects| in |promise|'s [=relevant Realm=].
        1. Return |promise|.
    </section>

    <section algorithm="navigator-service-worker-startMessages">
      <h4 id="navigator-service-worker-startMessages">{{ServiceWorkerContainer/startMessages()}}</h4>

      The <dfn method for="ServiceWorkerContainer"><code>startMessages()</code></dfn> method steps are to enable [=this=]'s [=ServiceWorkerContainer/client message queue=] if it is not enabled.
    </section>

    <section>
      <h4 id="service-worker-container-event-handlers">Event handlers</h4>

      The following are the <a>event handlers</a> (and their corresponding <a>event handler event types</a>) that *must* be supported, as <a>event handler IDL attributes</a>, by all objects implementing the {{ServiceWorkerContainer}} interface:

      <table class="data">
        <thead>
          <tr>
            <th><a>event handler</a></th>
            <th><a>event handler event type</a></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><dfn attribute for="ServiceWorkerContainer"><code>oncontrollerchange</code></dfn></td>
            <td>{{ServiceWorkerContainer/controllerchange!!event}}</td>
          </tr>
          <tr>
            <td><dfn attribute for="ServiceWorkerContainer"><code>onmessage</code></dfn></td>
            <td>{{ServiceWorkerContainer/message!!event}}</td>
          </tr>
          <tr>
            <td><dfn attribute for="ServiceWorkerContainer"><code>onmessageerror</code></dfn></td>
            <td>{{ServiceWorkerContainer/messageerror!!event}}</td>
          </tr>
        </tbody>
      </table>

      The first time the {{ServiceWorkerContainer/onmessage}} setter steps are performed, enable [=this=]'s [=ServiceWorkerContainer/client message queue=].
    </section>
  </section>
  <section>
    <h3 id="document-context-events">Events</h3>

    The following event is dispatched on {{ServiceWorker}} object:

    <table class="data">
      <thead>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Dispatched when&mldr;</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><dfn event for="ServiceWorker"><code>statechange</code></dfn></td>
          <td>{{Event}}</td>
          <td>The {{ServiceWorker/state}} attribute of the {{ServiceWorker}} object is changed.</td>
        </tr>
      </tbody>
    </table>

    The following event is dispatched on {{ServiceWorkerRegistration}} object:

    <table class="data">
      <thead>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Dispatched when&mldr;</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><dfn event for="ServiceWorkerRegistration" id="service-worker-registration-updatefound-event"><code>updatefound</code></dfn></td>
          <td>{{Event}}</td>
          <td>The [=ServiceWorkerRegistration/service worker registration=]'s <a>installing worker</a> changes. (See step 8 of the <a>Install</a> algorithm.)</td>
        </tr>
      </tbody>
    </table>

    The following events are dispatched on {{ServiceWorkerContainer}} object:

    <table class="data" dfn-for="ServiceWorkerContainer">
      <thead>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Dispatched when&mldr;</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><dfn event id="service-worker-container-controllerchange-event"><code>controllerchange</code></dfn></td>
          <td>{{Event}}</td>
          <td>The [=ServiceWorkerContainer/service worker client=]'s <a>active service worker</a> changes. (See step 9.2 of the <a>Activate</a> algorithm. The <a>skip waiting flag</a> of a [=/service worker=] causes <a lt="activate">activation</a> of the [=/service worker registration=] to occur while [=/service worker clients=] are <a>using</a> the [=/service worker registration=], {{ServiceWorkerContainer/controller|navigator.serviceWorker.controller}} immediately reflects the <a>active worker</a> as the [=/service worker=] that <a>controls</a> the [=/service worker client=].)</td>
        </tr>
        <tr>
          <td><dfn event id="service-worker-container-message-event"><code>message</code></dfn></td>
          <td>{{Event}}</td>
          <td>The [=ServiceWorkerContainer/service worker client=] receives a message from a [=/service worker=]. See {{Client/postMessage(message, options)}}.</td>
        </tr>
        <tr>
          <td><dfn event id="service-worker-container-messageerror-event"><code>messageerror</code></dfn></td>
          <td>{{Event}}</td>
          <td>The [=ServiceWorkerContainer/service worker client=] is sent a message that cannot be deserialized from a [=/service worker=]. See {{Client/postMessage(message, options)}}.</td>
        </tr>
      </tbody>
    </table>
  </section>
</section>

<section>
    <h3 id="navigation-preload-manager">{{NavigationPreloadManager}}</h3>

    <pre class="idl">
      [SecureContext, Exposed=(Window,Worker)]
      interface NavigationPreloadManager {
        Promise&lt;undefined&gt; enable();
        Promise&lt;undefined&gt; disable();
        Promise&lt;undefined&gt; setHeaderValue(ByteString value);
        Promise&lt;NavigationPreloadState&gt; getState();
      };

      dictionary NavigationPreloadState {
        boolean enabled = false;
        ByteString headerValue;
      };
    </pre>

    <section algorithm="navigation-preload-manager-enable">
      <h4 id="navigation-preload-manager-enable">{{NavigationPreloadManager/enable()}}</h4>

      The <dfn method for="NavigationPreloadManager"><code>enable()</code></dfn> method steps are:

        1. Let |promise| be [=a new promise=].
        1. Run the following steps [=in parallel=]:
          1. Let |registration| be [=this=]'s associated [=/service worker registration=].
          1. If |registration|'s [=active worker=] is null, [=reject=] |promise| with an "{{InvalidStateError}}" {{DOMException}}, and abort these steps.
          1. Set |registration|'s [=navigation preload enabled flag=].
          1. Resolve |promise| with undefined.
        1. Return |promise|.
    </section>

    <section algorithm="navigation-preload-manager-disable">
      <h4 id="navigation-preload-manager-disable">{{NavigationPreloadManager/disable()}}</h4>

      The <dfn method for="NavigationPreloadManager"><code>disable()</code></dfn> method steps are:

        1. Let |promise| be [=a new promise=].
        1. Run the following steps [=in parallel=]:
          1. Let |registration| be [=this=]'s associated [=/service worker registration=].
          1. If |registration|'s [=active worker=] is null, [=reject=] |promise| with an "{{InvalidStateError}}" {{DOMException}}, and abort these steps.
          1. Unset |registration|'s [=navigation preload enabled flag=].
          1. Resolve |promise| with undefined.
        1. Return |promise|.
    </section>

    <section algorithm="navigation-preload-manager-setheadervalue">
      <h4 id="navigation-preload-manager-setheadervalue">{{NavigationPreloadManager/setHeaderValue(value)}}</h4>

      The <dfn method for="NavigationPreloadManager"><code>setHeaderValue(|value|)</code></dfn> method steps are:

        1. Let |promise| be [=a new promise=].
        1. Run the following steps [=in parallel=]:
          1. Let |registration| be [=this=]'s associated [=/service worker registration=].
          1. If |registration|'s [=active worker=] is null, [=reject=] |promise| with an "{{InvalidStateError}}" {{DOMException}}, and abort these steps.
          1. Set |registration|'s [=navigation preload header value=] to |value|.
          1. Resolve |promise| with undefined.
        1. Return |promise|.
    </section>

    <section algorithm="navigation-preload-manager-getstate">
      <h4 id="navigation-preload-manager-getstate">{{NavigationPreloadManager/getState()}}</h4>

      The <dfn method for="NavigationPreloadManager"><code>getState()</code></dfn> method steps are:

        1. Let |promise| be [=a new promise=].
        1. Run the following steps [=in parallel=]:
          1. Let |registration| be [=this=]'s associated [=/service worker registration=].
          1. Let |state| be a new {{NavigationPreloadState}} dictionary.
          1. If |registration|'s [=navigation preload enabled flag=] is set, set |state|["{{NavigationPreloadState/enabled}}"] to true.
          1. Set |state|["{{NavigationPreloadState/headerValue}}"] to |registration|'s [=navigation preload header value=].
          1. Resolve |promise| with |state|.
        1. Return |promise|.
    </section>

  </section>

<section>
  <h2 id="execution-context">Execution Context</h2>

  <div class="example">
    Serving Cached Resources:

    <pre highlight="js">
      // caching.js
      self.addEventListener("install", event => {
        event.waitUntil(
          // Open a cache of resources.
          caches.open("shell-v1").then(cache => {
            // Begins the process of fetching them.
            // The coast is only clear when all the resources are ready.
            return cache.addAll([
              "/app.html",
              "/assets/v1/base.css",
              "/assets/v1/app.js",
              "/assets/v1/logo.png",
              "/assets/v1/intro_video.webm"
            ]);
          })
        );
      });

      self.addEventListener("fetch", event => {
        // No "fetch" events are dispatched to the service worker until it
        // successfully installs and activates.

        // All operations on caches are async, including matching URLs, so we use
        // promises heavily. e.respondWith() even takes promises to enable this:
        event.respondWith(
          caches.match(e.request).then(response => {
            return response || fetch(e.request);
          }).catch(() => {
            return caches.match("/fallback.html");
          })
        );
      });
    </pre>
  </div>

  <section>
    <h3 id="serviceworkerglobalscope-interface">{{ServiceWorkerGlobalScope}}</h3>

    <pre class="idl">
      [Global=(Worker,ServiceWorker), Exposed=ServiceWorker]
      interface ServiceWorkerGlobalScope : WorkerGlobalScope {
        [SameObject] readonly attribute Clients clients;
        [SameObject] readonly attribute ServiceWorkerRegistration registration;
        [SameObject] readonly attribute ServiceWorker serviceWorker;

        [NewObject] Promise&lt;undefined&gt; skipWaiting();

        attribute EventHandler oninstall;
        attribute EventHandler onactivate;
        attribute EventHandler onfetch;

        attribute EventHandler onmessage;
        attribute EventHandler onmessageerror;
      };
    </pre>

    A {{ServiceWorkerGlobalScope}} object represents the global execution context of a [=/service worker=]. A {{ServiceWorkerGlobalScope}} object has an associated <dfn export for="ServiceWorkerGlobalScope">service worker</dfn> (a [=/service worker=]). A {{ServiceWorkerGlobalScope}} object has an associated <dfn for="ServiceWorkerGlobalScope">force bypass cache for import scripts flag</dfn>. It is initially unset.

    Note: {{ServiceWorkerGlobalScope}} object provides generic, event-driven, time-limited script execution contexts that run at an origin. Once successfully <a>registered</a>, a [=/service worker=] is started, kept alive and killed by their relationship to events, not [=/service worker clients=]. Any type of synchronous requests must not be initiated inside of a [=/service worker=].

    <section>
      <h4 id="service-worker-global-scope-clients">{{ServiceWorkerGlobalScope/clients}}</h4>

      The <dfn attribute for="ServiceWorkerGlobalScope"><code>clients</code></dfn> getter steps are to return the {{Clients}} object that is associated with [=this=].
    </section>

    <section>
      <h4 id="service-worker-global-scope-registration">{{ServiceWorkerGlobalScope/registration}}</h4>

      The <dfn attribute for="ServiceWorkerGlobalScope"><code>registration</code></dfn> getter steps are to return the result of [=getting the service worker registration object=] representing [=this=]'s [=ServiceWorkerGlobalScope/service worker=]'s [=containing service worker registration=] in [=this=]'s [=relevant settings object=].
    </section>

    <section>
      <h4 id="service-worker-global-scope-serviceworker">{{ServiceWorkerGlobalScope/serviceWorker}}</h4>

      The <dfn attribute for="ServiceWorkerGlobalScope"><code>serviceWorker</code></dfn> getter steps are to return the result of [=getting the service worker object=] that represents [=this=]'s [=ServiceWorkerGlobalScope/service worker=] in [=this=]'s [=relevant settings object=].
    </section>

    <section algorithm="service-worker-global-scope-skipwaiting">
      <h4 id="service-worker-global-scope-skipwaiting">{{ServiceWorkerGlobalScope/skipWaiting()}}</h4>

      Note: The {{ServiceWorkerGlobalScope/skipWaiting()}} method allows this [=/service worker=] to progress from the [=service worker/registration=]'s <a lt="waiting worker">waiting</a> position to <a lt="active worker">active</a> even while [=/service worker clients=] are <a>using</a> the [=service worker/registration=].

      The <dfn method for="ServiceWorkerGlobalScope"><code>skipWaiting()</code></dfn> method steps are:

        1. Let |promise| be a new <a>promise</a>.
        1. Run the following substeps <a>in parallel</a>:
            1. Set [=ServiceWorkerGlobalScope/service worker=]'s <a>skip waiting flag</a>.
            1. Invoke [=Try Activate=] with [=ServiceWorkerGlobalScope/service worker=]'s [=containing service worker registration=].
            1. Resolve |promise| with undefined.
        1. Return |promise|.
    </section>

    <section>
      <h4 id="service-worker-global-scope-event-handlers">Event handlers</h4>

      The following are the <a>event handlers</a> (and their corresponding <a>event handler event types</a>) that *must* be supported, as <a>event handler IDL attributes</a>, by all objects implementing the {{ServiceWorkerGlobalScope}} interface:

      <table class="data">
        <thead>
          <tr>
            <th><a>event handler</a></th>
            <th><a>event handler event type</a></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><dfn attribute for="ServiceWorkerGlobalScope"><code>oninstall</code></dfn></td>
            <td>{{install!!event}}</td>
          </tr>
          <tr>
            <td><dfn attribute for="ServiceWorkerGlobalScope"><code>onactivate</code></dfn></td>
            <td>{{activate!!event}}</td>
          </tr>
          <tr>
            <td><dfn attribute for="ServiceWorkerGlobalScope"><code>onfetch</code></dfn></td>
            <td>{{fetch!!event}}</td>
          </tr>
          <tr>
            <td><dfn attribute for="ServiceWorkerGlobalScope"><code>onmessage</code></dfn></td>
            <td>{{message!!event}}</td>
          </tr>
          <tr>
            <td><dfn attribute for="ServiceWorkerGlobalScope"><code>onmessageerror</code></dfn></td>
            <td>{{messageerror!!event}}</td>
          </tr>
        </tbody>
      </table>
    </section>
  </section>

  <section>
    <h3 id="client-interface">{{Client}}</h3>

    <pre class="idl">
      [Exposed=ServiceWorker]
      interface Client {
        readonly attribute USVString url;
        readonly attribute FrameType frameType;
        readonly attribute DOMString id;
        readonly attribute ClientType type;
        undefined postMessage(any message, sequence&lt;object&gt; transfer);
        undefined postMessage(any message, optional StructuredSerializeOptions options = {});
      };

      [Exposed=ServiceWorker]
      interface WindowClient : Client {
        readonly attribute VisibilityState visibilityState;
        readonly attribute boolean focused;
        [SameObject] readonly attribute FrozenArray&lt;USVString&gt; ancestorOrigins;
        [NewObject] Promise&lt;WindowClient&gt; focus();
        [NewObject] Promise&lt;WindowClient?&gt; navigate(USVString url);
      };

      enum FrameType {
        "auxiliary",
        "top-level",
        "nested",
        "none"
      };
    </pre>

    A {{Client}} object has an associated <dfn id="dfn-service-worker-client-service-worker-client" for="Client">service worker client</dfn> (a [=/service worker client=]).

    A {{Client}} object has an associated <dfn id="dfn-service-worker-client-frame-type" for="Client">frame type</dfn>, which is one of "`auxiliary`", "`top-level`", "`nested`", and "`none`". Unless stated otherwise it is "`none`".

    A {{WindowClient}} object has an associated <dfn id="dfn-service-worker-client-browsing-context" for="WindowClient">browsing context</dfn>, which is its [=Client/service worker client=]'s [=environment settings object/global object=]'s [=/browsing context=].

    A {{WindowClient}} object has an associated <dfn id="dfn-service-worker-client-visibilitystate">visibility state</dfn>, which is one of {{Document/visibilityState}} attribute value.

    A {{WindowClient}} object has an associated <dfn id="dfn-service-worker-client-focusstate">focus state</dfn>, which is either true or false (initially false).

    A {{WindowClient}} object has an associated <dfn for="WindowClient">ancestor origins array</dfn>.

    <section>
      <h4 id="client-url">{{Client/url}}</h4>

      The <dfn attribute for="Client"><code>url</code></dfn> getter steps are to return [=this=]'s associated [=Client/service worker client=]'s <a lt="URL serializer">serialized</a> <a>creation URL</a>.
    </section>

    <section>
      <h4 id="client-frametype">{{Client/frameType}}</h4>

      The <dfn attribute for="Client"><code>frameType</code></dfn> getter steps are to return [=this=]'s [=frame type=].
    </section>

    <section>
      <h4 id="client-id">{{Client/id}}</h4>

      The <dfn attribute for="Client"><code>id</code></dfn> getter steps are to return [=this=]'s associated [=Client/service worker client=]'s [=environment/id=].
    </section>

    <section>
      <h4 id="client-type">{{Client/type}}</h4>

      The <dfn attribute for="Client"><code>type</code></dfn> getter steps are:

        1. Let |client| be [=this=]'s [=Client/service worker client=].
        1. If |client| is an [=environment settings object=], then:
            1. If |client| is a [=window client=], return {{ClientType/"window"}}.
            1. Else if |client| is a [=dedicated worker client=], return {{ClientType/"worker"}}.
            1. Else if |client| is a [=shared worker client=], return {{ClientType/"sharedworker"}}.
        1. Else:
            1. Return {{ClientType/"window"}}.
    </section>

    <section algorithm="client-postmessage">
      <h4 id="client-postmessage">{{Client/postMessage(message, transfer)}}</h4>

      The <dfn method for="Client"><code>postMessage(|message|, |transfer|)</code></dfn> method steps are:

        1. Let |options| be «[ "transfer" → |transfer| ]».
        1. Invoke {{Client/postMessage(message, options)}} with |message| and |options| as the arguments.
    </section>

    <section algorithm="client-postmessage-options">
      <h4 id="client-postmessage-options">{{Client/postMessage(message, options)}}</h4>

      The <dfn method for="Client"><code>postMessage(|message|, |options|)</code></dfn> method steps are:

        1. Let |contextObject| be [=this=].
        1. Let |sourceSettings| be the |contextObject|'s [=relevant settings object=].
        1. Let |serializeWithTransferResult| be <a abstract-op>StructuredSerializeWithTransfer</a>(|message|, |options|["{{StructuredSerializeOptions/transfer}}"]). Rethrow any exceptions.
        1. Run the following steps [=in parallel=]:
            1. Let |targetClient| be null.
            1. For each [=/service worker client=] |client|:
                1. If |client| is the |contextObject|'s [=Client/service worker client=], set |targetClient| to |client|, and [=break=].
            1. If |targetClient| is null, return.
            1. Let |destination| be the {{ServiceWorkerContainer}} object whose associated [=ServiceWorkerContainer/service worker client=] is |targetClient|.
            1. Add a [=task=] that runs the following steps to |destination|'s [=ServiceWorkerContainer/client message queue=]:
                1. Let |origin| be the [=serialization of an origin|serialization=] of |sourceSettings|'s [=environment settings object/origin=].
                1. Let |source| be the result of [=getting the service worker object=] that represents |contextObject|'s [=relevant global object=]'s [=ServiceWorkerGlobalScope/service worker=] in |targetClient|.
                1. Let |deserializeRecord| be <a abstract-op>StructuredDeserializeWithTransfer</a>(|serializeWithTransferResult|, |destination|'s [=relevant Realm=]).

                    If this throws an exception, catch it, [=fire an event=] named {{messageerror!!event}} at |destination|, using {{MessageEvent}}, with the {{MessageEvent/origin}} attribute initialized to |origin| and the {{MessageEvent/source}} attribute initialized to |source|, and then abort these steps.
                1. Let |messageClone| be |deserializeRecord|.\[[Deserialized]].
                1. Let |newPorts| be a new [=frozen array type|frozen array=] consisting of all {{MessagePort}} objects in |deserializeRecord|.\[[TransferredValues]], if any.
                1. [=Dispatch|Dispatch an event=] named {{Window/message!!event}} at |destination|, using {{MessageEvent}}, with the {{MessageEvent/origin}} attribute initialized to |origin|, the {{MessageEvent/source}} attribute initialized to |source|, the {{MessageEvent/data}} attribute initialized to |messageClone|, and the {{MessageEvent/ports}} attribute initialized to |newPorts|.
    </section>

    <section>
      <h4 id="client-visibilitystate">{{WindowClient/visibilityState}}</h4>

      The <dfn attribute for="WindowClient"><code>visibilityState</code></dfn> getter steps are to return [=this=]'s <a>visibility state</a>.
    </section>

    <section>
      <h4 id="client-focused">{{WindowClient/focused}}</h4>

      The <dfn attribute for="WindowClient"><code>focused</code></dfn> getter steps are to return [=this=]'s <a>focus state</a>.
    </section>

    <section>
      <h4 id="client-ancestororigins">{{WindowClient/ancestorOrigins}}</h4>

      The <dfn attribute for="WindowClient"><code>ancestorOrigins</code></dfn> getter steps are to return [=this=]'s associated [=WindowClient/ancestor origins array=].
    </section>

    <section algorithm="client-focus">
      <h4 id="client-focus">{{WindowClient/focus()}}</h4>

      The <dfn method for="WindowClient"><code>focus()</code></dfn> method steps are:

        1. If this algorithm is not <a>triggered by user activation</a>, return a <a>promise</a> rejected with an "{{InvalidAccessError}}" {{DOMException}}.
        1. Let |serviceWorkerEventLoop| be the [=surrounding agent=]'s [=agent/event loop=].
        1. Let |promise| be a new <a>promise</a>.
        1. [=Queue a task=] to run the following steps on [=this=]'s associated [=Client/service worker client=]'s [=responsible event loop=] using the [=user interaction task source=]:
            1. Run the [=focusing steps=] with [=this=]'s [=WindowClient/browsing context=].
            1. Let |frameType| be the result of running [=Get Frame Type=] with [=this=]'s [=WindowClient/browsing context=].
            1. Let |visibilityState| be [=this=]'s [=WindowClient/browsing context=]'s [=active document=]'s {{Document/visibilityState}} attribute value.
            1. Let |focusState| be the result of running the [=has focus steps=] with [=this=]'s [=WindowClient/browsing context=]'s [=active document=].
            1. Let |ancestorOriginsList| be [=this=]'s [=WindowClient/browsing context=]'s [=active document=]'s [=relevant global object=]'s {{Location}} object's [=Location/ancestor origins list=]'s associated list.
            1. [=Queue a task=] to run the following steps on |serviceWorkerEventLoop| using the [=DOM manipulation task source=]:
                1. Let |windowClient| be the result of running [=Create Window Client=] with [=this=]'s associated [=Client/service worker client=], |frameType|, |visibilityState|, |focusState|, and |ancestorOriginsList|.
                1. If |windowClient|'s [=focus state=] is true, resolve |promise| with |windowClient|.
                1. Else, reject |promise| with a `TypeError`.
        1. Return |promise|.
    </section>

    <section algorithm="client-navigate">
      <h4 id="client-navigate">{{WindowClient/navigate(url)}}</h4>

      The <dfn method for="WindowClient"><code>navigate(url)</code></dfn> method steps are:

        1. Let |url| be the result of <a lt="URL parser">parsing</a> |url| with [=this=]'s <a>relevant settings object</a>'s <a>API base URL</a>.
        1. If |url| is failure, return a <a>promise</a> rejected with a <code>TypeError</code>.
        1. If |url| is <code>about:blank</code>, return a <a>promise</a> rejected with a <code>TypeError</code>.
        1. If [=this=]'s associated [=Client/service worker client=]'s <a>active service worker</a> is not [=this=]'s <a>relevant global object</a>'s [=ServiceWorkerGlobalScope/service worker=], return a <a>promise</a> rejected with a <code>TypeError</code>.
        1. Let |serviceWorkerEventLoop| be the [=current global object=]'s [=event loop=].
        1. Let |promise| be a new <a>promise</a>.
        1. [=Queue a task=] to run the following steps on [=this=]'s associated [=Client/service worker client=]'s [=responsible event loop=] using the [=user interaction task source=]:
            1. Let |browsingContext| be [=this=]'s [=WindowClient/browsing context=].
            1. If |browsingContext| has [=discard a document|discarded=] its {{Document}}, [=queue a task=] to reject |promise| with a `TypeError`, on |serviceWorkerEventLoop| using the [=DOM manipulation task source=], and abort these steps.
            1. *HandleNavigate*: [=Navigate=] |browsingContext| to |url| with [=exceptions enabled flag|exceptions enabled=]. The [=source browsing context=] must be |browsingContext|.
            1. If the algorithm steps invoked in the step labeled *HandleNavigate* [=throws=] an exception, [=queue a task=] to reject |promise| with the exception, on |serviceWorkerEventLoop| using the [=DOM manipulation task source=], and abort these steps.
            1. Let |frameType| be the result of running [=Get Frame Type=] with |browsingContext|.
            1. Let |visibilityState| be |browsingContext|'s <a>active document</a>'s {{Document/visibilityState}} attribute value.
            1. Let |focusState| be the result of running the [=has focus steps=] with |browsingContext|'s [=active document=].
            1. Let |ancestorOriginsList| be |browsingContext|'s [=active document=]'s [=relevant global object=]'s {{Location}} object's [=Location/ancestor origins list=]'s associated list.
            1. [=Queue a task=] to run the following steps on |serviceWorkerEventLoop| using the [=DOM manipulation task source=]:
                1. If |browsingContext|'s {{Window}} object's <a>environment settings object</a>'s <a>creation URL</a>'s [=url/origin=] is not the <a lt="same origin">same</a> as the [=ServiceWorkerGlobalScope/service worker=]'s [=environment settings object/origin=], resolve |promise| with null and abort these steps.
                1. Let |windowClient| be the result of running [=Create Window Client=] with [=this=]'s [=Client/service worker client=], |frameType|, |visibilityState|, |focusState|, and |ancestorOriginsList|.
                1. Resolve |promise| with |windowClient|.
        1. Return |promise|.
    </section>
  </section>

  <section>
    <h3 id="clients-interface">{{Clients}}</h3>

    <pre class="idl">
      [Exposed=ServiceWorker]
      interface Clients {
        // The objects returned will be new instances every time
        [NewObject] Promise&lt;(Client or undefined)&gt; get(DOMString id);
        [NewObject] Promise&lt;FrozenArray&lt;Client&gt;&gt; matchAll(optional ClientQueryOptions options = {});
        [NewObject] Promise&lt;WindowClient?&gt; openWindow(USVString url);
        [NewObject] Promise&lt;undefined&gt; claim();
      };
    </pre>
    <pre class="idl" id="serviceworker-client-query-options-dictionary">
      dictionary ClientQueryOptions {
        boolean includeUncontrolled = false;
        ClientType type = "window";
      };
    </pre>
    <pre class="idl" id="client-type-enum">
      enum ClientType {
        "window",
        "worker",
        "sharedworker",
        "all"
      };
    </pre>

    The user agent *must* create a {{Clients}} object when a {{ServiceWorkerGlobalScope}} object is created and associate it with that object.

    <section algorithm="clients-get">
      <h4 id="clients-get">{{Clients/get(id)}}</h4>

      The <dfn method for="Clients"><code>get(|id|)</code></dfn> method steps are:

        1. Let |promise| be a new <a>promise</a>.
        1. Run these substeps <a>in parallel</a>:
            1. For each [=/service worker client=] |client| whose [=service worker client/origin=] is the <a lt="same origin">same</a> as the associated [=ServiceWorkerGlobalScope/service worker=]'s [=environment settings object/origin=]:
                1. If |client|'s [=environment/id=] is not |id|, [=continue=].
                1. Wait for either |client|'s [=environment/execution ready flag=] to be set or for |client|'s [=discarded flag=] to be set.
                1. If |client|'s [=environment/execution ready flag=] is set, then invoke [=Resolve Get Client Promise=] with |client| and |promise|, and abort these steps.
            1. Resolve |promise| with undefined.
        1. Return |promise|.
    </section>

    <section algorithm="clients-matchall">
      <h4 id="clients-matchall">{{Clients/matchAll(options)}}</h4>

      The <dfn method for="Clients"><code>matchAll(|options|)</code></dfn> method steps are:

        1. Let |promise| be [=a new promise=].
        1. Run the following steps [=in parallel=]:
            1. Let |targetClients| be a new [=list=].
            1. For each [=/service worker client=] |client| whose [=service worker client/origin=] is the [=same origin|same=] as the associated [=ServiceWorkerGlobalScope/service worker=]'s [=environment settings object/origin=]:
                1. If |client|'s [=environment/execution ready flag=] is unset or |client|'s [=discarded flag=] is set, [=continue=].
                1. If |client| is not a [=secure context=], [=continue=].
                1. If |options|["{{ClientQueryOptions/includeUncontrolled}}"] is false, and if |client|'s [=active service worker=] is not the associated [=ServiceWorkerGlobalScope/service worker=], [=continue=].
                1. Add |client| to |targetClients|.
            1. Let |matchedWindowData| be a new [=list=].
            1. Let |matchedClients| be a new [=list=].
            1. For each [=/service worker client=] |client| in |targetClients|:
                1. If |options|["{{ClientQueryOptions/type}}"] is {{ClientType/"window"}} or {{ClientType/"all"}}, and |client| is not an [=environment settings object=] or is a [=window client=], then:
                    1. Let |windowData| be «[ "client" → |client|, "ancestorOriginsList" → a new [=list=] ]».
                    1. Let |browsingContext| be null.
                    1. Let |isClientEnumerable| be true.
                    1. If |client| is an [=environment settings object=], set |browsingContext| to |client|'s [=environment settings object/global object=]'s [=/browsing context=].
                    1. Else, set |browsingContext| to |client|’s [=environment/target browsing context=].
                    1. [=Queue a task=] |task| to run the following substeps on |browsingContext|'s [=event loop=] using the [=user interaction task source=]:
                        1. If |browsingContext| has been [=discard|discarded=], then set |isClientEnumerable| to false and abort these steps.
                        1. If |client| is a window client and |client|'s [=responsible document=] is not |browsingContext|'s [=active document=], then set |isClientEnumerable| to false and abort these steps.
                        1. Set |windowData|["`frameType`"] to the result of running [=Get Frame Type=] with |browsingContext|.
                        1. Set |windowData|["`visibilityState`"] to |browsingContext|'s [=active document=]'s {{Document/visibilityState}} attribute value.
                        1. Set |windowData|["`focusState`"] to the result of running the [=has focus steps=] with |browsingContext|'s [=active document=] as the argument.
                        1. If |client| is a [=window client=], then set |windowData|["`ancestorOriginsList`"] to |browsingContext|'s [=active document=]'s [=relevant global object=]'s {{Location}} object's [=Location/ancestor origins list=]'s associated list.
                    1. Wait for |task| to have executed.

                        Note: Wait is a blocking wait, but implementers may run the iterations in parallel as long as the state is not broken.

                    1. If |isClientEnumerable| is true, then:
                        1. Add |windowData| to |matchedWindowData|.
                1. Else if |options|["{{ClientQueryOptions/type}}"] is {{ClientType/"worker"}} or {{ClientType/"all"}} and |client| is a [=dedicated worker client=], or |options|["{{ClientQueryOptions/type}}"] is {{ClientType/"sharedworker"}} or {{ClientType/"all"}} and |client| is a [=shared worker client=], then:
                    1. Add |client| to |matchedClients|.
            1. [=Queue a task=] to run the following steps on |promise|'s [=relevant settings object=]'s [=responsible event loop=] using the [=DOM manipulation task source=]:
                1. Let |clientObjects| be a new [=list=].
                1. [=list/For each=] |windowData| in |matchedWindowData|:
                    1. Let |windowClient| be the result of running [=Create Window Client=] algorithm with |windowData|["`client`"], |windowData|["`frameType`"], |windowData|["`visibilityState`"], |windowData|["`focusState`"], and |windowData|["`ancestorOriginsList`"] as the arguments.
                    1. [=Append=] |windowClient| to |clientObjects|.
                1. [=list/For each=] |client| in |matchedClients|:
                    1. Let |clientObject| be the result of running [=Create Client=] algorithm with |client| as the argument.
                    1. [=Append=] |clientObject| to |clientObjects|.
                1. Sort |clientObjects| such that:
                    * {{WindowClient}} objects whose [=WindowClient/browsing context=] has been [=focusing steps|focused=] are placed first, sorted in the most recently [=focusing steps|focused=] order.
                    * {{WindowClient}} objects whose [=WindowClient/browsing context=] has never been [=focusing steps|focused=] are placed next, sorted in their [=Client/service worker client=]'s creation order.
                    * {{Client}} objects whose associated [=Client/service worker client=] is a [=worker client=] are placed next, sorted in their [=Client/service worker client=]'s creation order.

                    Note: [=Window clients=] are always placed before [=worker clients=].

                1. Resolve |promise| with [=create a frozen array|a new frozen array of=] |clientObjects| in |promise|'s [=relevant Realm=].
        1. Return |promise|.
    </section>

    <section algorithm="clients-openwindow">
      <h4 id="clients-openwindow">{{Clients/openWindow(url)}}</h4>

      The <dfn method for="Clients"><code>openWindow(|url|)</code></dfn> method steps are:
        1. Let |url| be the result of <a lt="URL parser">parsing</a> |url| with [=this=]'s <a>relevant settings object</a>'s <a>API base URL</a>.
        1. If |url| is failure, return a <a>promise</a> rejected with a <code>TypeError</code>.
        1. If |url| is <code>about:blank</code>, return a <a>promise</a> rejected with a <code>TypeError</code>.
        1. If this algorithm is not <a>triggered by user activation</a>, return a <a>promise</a> rejected with an "{{InvalidAccessError}}" {{DOMException}}.
        1. Let |serviceWorkerEventLoop| be the [=current global object=]'s [=event loop=].
        1. Let |promise| be a new <a>promise</a>.
        1. Run these substeps <a>in parallel</a>:
            1. Let |newContext| be a new [=top-level browsing context=].
            1. [=Queue a task=] to run the following steps on |newContext|'s {{Window}} object's [=environment settings object=]'s [=responsible event loop=] using the [=user interaction task source=]:
                1. *HandleNavigate*: [=Navigate=] |newContext| to |url| with [=exceptions enabled flag|exceptions enabled=] and [=replacement enabled=].
                1. If the algorithm steps invoked in the step labeled *HandleNavigate* [=throws=] an exception, [=queue a task=] to reject |promise| with the exception, on |serviceWorkerEventLoop| using the [=DOM manipulation task source=], and abort these steps.
                1. Let |frameType| be the result of running [=Get Frame Type=] with |newContext|.
                1. Let |visibilityState| be |newContext|'s <a>active document</a>'s {{Document/visibilityState}} attribute value.
                1. Let |focusState| be the result of running the <a>has focus steps</a> with |newContext|'s <a>active document</a> as the argument.
                1. Let |ancestorOriginsList| be |newContext|'s <a>active document</a>'s <a>relevant global object</a>'s {{Location}} object's [=Location/ancestor origins list=]'s associated list.
                1. [=Queue a task=] to run the following steps on |serviceWorkerEventLoop| using the [=DOM manipulation task source=]:
                    1. If |newContext|'s {{Window}} object's [=environment settings object=]'s [=creation URL=]'s [=environment settings object/origin=] is not the [=same origin|same=] as the [=ServiceWorkerGlobalScope/service worker=]'s [=environment settings object/origin=], resolve |promise| with null and abort these steps.
                    1. Let |client| be the result of running [=Create Window Client=] with |newContext|'s {{Window}} object's [=environment settings object=], |frameType|, |visibilityState|, |focusState|, and |ancestorOriginsList| as the arguments.
                    1. Resolve |promise| with |client|.
        1. Return |promise|.
    </section>

    <section algorithm="clients-claim">
      <h4 id="clients-claim">{{Clients/claim()}}</h4>

      The <dfn method for="Clients"><code>claim()</code></dfn> method steps are:

        1. If the [=ServiceWorkerGlobalScope/service worker=] is not an <a>active worker</a>, return a <a>promise</a> rejected with an "{{InvalidStateError}}" {{DOMException}}.
        1. Let |promise| be a new <a>promise</a>.
        1. Run the following substeps <a>in parallel</a>:
            1. For each [=/service worker client=] |client| whose [=service worker client/origin=] is the <a lt="same origin">same</a> as the [=ServiceWorkerGlobalScope/service worker=]'s [=environment settings object/origin=]:
                1. If |client|'s [=environment/execution ready flag=] is unset or |client|'s [=discarded flag=] is set, [=continue=].
                1. If |client| is not a [=secure context=], [=continue=].
                1. Let |registration| be the result of running <a>Match Service Worker Registration</a> algorithm passing |client|'s <a>creation URL</a> as the argument.
                1. If |registration| is not the [=ServiceWorkerGlobalScope/service worker=]'s <a>containing service worker registration</a>, [=continue=].

                    Note: |registration| will be null if the [=ServiceWorkerGlobalScope/service worker=]'s [=containing service worker registration=] is [=service worker registration/unregistered=].

                1. If |client|'s <a>active service worker</a> is not the [=ServiceWorkerGlobalScope/service worker=], then:
                    1. Invoke <a>Handle Service Worker Client Unload</a> with |client| as the argument.
                    1. Set |client|'s <a>active service worker</a> to [=ServiceWorkerGlobalScope/service worker=].
                    1. Invoke <a>Notify Controller Change</a> algorithm with |client| as the argument.
            1. Resolve |promise| with undefined.
        1. Return |promise|.
    </section>
  </section>

  <section>
    <h3 id="extendableevent-interface">{{ExtendableEvent}}</h3>

    <pre class="idl">
      [Exposed=ServiceWorker]
      interface ExtendableEvent : Event {
        constructor(DOMString type, optional ExtendableEventInit eventInitDict = {});
        undefined waitUntil(Promise&lt;any&gt; f);
      };
    </pre>
    <pre class="idl" id="extendable-event-init-dictionary">
      dictionary ExtendableEventInit : EventInit {
        // Defined for the forward compatibility across the derived events
      };
    </pre>

    An {{ExtendableEvent}} object has an associated <dfn export for="ExtendableEvent">extend lifetime promises</dfn> (an array of <a>promises</a>). It is initially an empty array.

    An {{ExtendableEvent}} object has an associated <dfn for="ExtendableEvent">pending promises count</dfn> (the number of pending promises in the [=ExtendableEvent/extend lifetime promises=]). It is initially set to zero.

    An {{ExtendableEvent}} object has an associated <dfn export for="ExtendableEvent">timed out flag</dfn>. It is initially unset, and is set after an optional user agent imposed delay if the [=ExtendableEvent/pending promises count=] is greater than zero.

    An {{ExtendableEvent}} object is said to be <dfn export for="ExtendableEvent">active</dfn> when its [=ExtendableEvent/timed out flag=] is unset and either its [=ExtendableEvent/pending promises count=] is greater than zero or its [=dispatch flag=] is set.

    [=/Service workers=] have two <a>lifecycle events</a>, {{install!!event}} and {{activate!!event}}. [=/Service workers=] use the {{ExtendableEvent}} interface for {{activate!!event}} event and {{install!!event}} event.

    <a href="#extensibility">Service worker extensions</a> that <a href="#extension-to-service-worker-global-scope">define event handlers</a> *may* also use or extend the {{ExtendableEvent}} interface.

    <section algorithm="wait-until-method">
      <h4 id="wait-until-method">{{ExtendableEvent/waitUntil()|event.waitUntil(f)}}</h4>

      Note: {{ExtendableEvent/waitUntil()}} method extends the lifetime of the event.

      The <dfn method for="ExtendableEvent"><code>waitUntil(|f|)</code></dfn> method steps are to [=ExtendableEvent/add lifetime promise=] |f| to [=this=].
    </section>

    <section algorithm="add-lifetime-promise">
      To <dfn for="ExtendableEvent" export>add lifetime promise</dfn> |promise| (a [=promise=]) to |event| (an {{ExtendableEvent}}), run these steps:

        1. If |event|'s {{Event/isTrusted}} attribute is false, [=throw=] an "{{InvalidStateError}}" {{DOMException}}.
        1. If |event| is not [=ExtendableEvent/active=], [=throw=] an "{{InvalidStateError}}" {{DOMException}}.

            Note: If no lifetime extension promise has been added in the task that called the event handlers, calling {{ExtendableEvent/waitUntil()}} in subsequent asynchronous tasks will throw.

        1. Add |promise| to |event|'s [=ExtendableEvent/extend lifetime promises=].
        1. Increment |event|'s [=ExtendableEvent/pending promises count=] by one.

            Note: The [=ExtendableEvent/pending promises count=] is incremented even if the given promise has already been settled. The corresponding count decrement is done in the microtask queued by the reaction to the promise.

        1. Upon [=upon fulfillment|fulfillment=] or [=upon rejection|rejection=] of |promise|, [=queue a microtask=] to run these substeps:
            1. Decrement |event|'s [=ExtendableEvent/pending promises count=] by one.
            1. If |event|'s [=ExtendableEvent/pending promises count=] is 0, then:
                1. Let |registration| be the [=current global object=]'s associated [=ServiceWorkerGlobalScope/service worker=]'s [=containing service worker registration=].
                1. If |registration| is [=service worker registration/unregistered=], invoke [=Try Clear Registration=] with |registration|.
                1. If |registration| is not null, invoke [=Try Activate=] with |registration|.

      The user agent *should not* [=terminate service worker|terminate=] a [=/service worker=] if [=Service Worker Has No Pending Events=] returns false for that [=/service worker=].
    </section>

    [=/Service workers=] and <a href="#extensibility">extensions</a> that <a href="#extension-to-service-worker-global-scope">define event handlers</a> *may* define their own behaviors, allowing the [=ExtendableEvent/extend lifetime promises=] to suggest operation length, and the rejected state of any of the <a>promise</a> in [=ExtendableEvent/extend lifetime promises=] to suggest operation failure.

    Note: [=/Service workers=] delay treating the [=installing worker=] as "`installed`" until all the [=promises=] in the {{install!!event}} event's [=extend lifetime promises=] resolve successfully. (See the relevant [Install algorithm step](#install-settle-step).) If any of the promises rejects, the installation fails. This is primarily used to ensure that a [=/service worker=] is not considered "`installed`" until all of the core caches it depends on are populated. Likewise, [=/service workers=] delay treating the [=active worker=] as "`activated`" until all the [=promises=] in the {{activate!!event}} event's [=extend lifetime promises=] settle. (See the relevant [Activate algorithm step](#activate-settle-step).) This is primarily used to ensure that any [=functional events=] are not dispatched to the [=/service worker=] until it upgrades database schemas and deletes the outdated cache entries.
  </section>

  <section>
    <h3 id="fetchevent-interface">{{FetchEvent}}</h3>

    <pre class="idl">
      [Exposed=ServiceWorker]
      interface FetchEvent : ExtendableEvent {
        constructor(DOMString type, FetchEventInit eventInitDict);
        [SameObject] readonly attribute Request request;
        readonly attribute Promise&lt;any&gt; preloadResponse;
        readonly attribute DOMString clientId;
        readonly attribute DOMString resultingClientId;
        readonly attribute DOMString replacesClientId;
        readonly attribute Promise&lt;undefined&gt; handled;

        undefined respondWith(Promise&lt;Response&gt; r);
      };
    </pre>
    <pre class="idl" id="fetch-event-init-dictionary">
      dictionary FetchEventInit : ExtendableEventInit {
        required Request request;
        Promise&lt;any&gt; preloadResponse;
        DOMString clientId = "";
        DOMString resultingClientId = "";
        DOMString replacesClientId = "";
        Promise&lt;undefined&gt; handled;
      };
    </pre>

    [=/Service workers=] have an essential <a>functional event</a> {{fetch!!event}}. For {{fetch!!event}} event, [=/service workers=] use the {{FetchEvent}} interface which extends the {{ExtendableEvent}} interface.

    Each event using {{FetchEvent}} interface has an associated <dfn for="FetchEvent">potential response</dfn> (a [=/response=]), initially set to null, and the following associated flags that are initially unset:

      * <dfn for="FetchEvent">wait to respond flag</dfn>
      * <dfn for="FetchEvent">respond-with entered flag</dfn>
      * <dfn for="FetchEvent">respond-with error flag</dfn>

    <section>
      <h4 id="fetch-event-request">{{FetchEvent/request|event.request}}</h4>

      <dfn attribute for="FetchEvent"><code>request</code></dfn> attribute *must* return the value it was initialized to.
    </section>

    <section>
      <h4 id="fetch-event-preloadresponse">{{FetchEvent/preloadResponse|event.preloadResponse}}</h4>

      <dfn attribute for="FetchEvent"><code>preloadResponse</code></dfn> attribute *must* return the value it was initialized to. When an <a>event</a> is created the attribute *must* be initialized to [=a promise resolved with=] undefined.
    </section>

    <section>
      <h4 id="fetch-event-clientid">{{FetchEvent/clientId|event.clientId}}</h4>

      <dfn attribute for="FetchEvent"><code>clientId</code></dfn> attribute *must* return the value it was initialized to. When an <a>event</a> is created the attribute *must* be initialized to the empty string.
    </section>

    <section>
      <h4 id="fetch-event-resultingclientid">{{FetchEvent/resultingClientId|event.resultingClientId}}</h4>

      <dfn attribute for="FetchEvent"><code>resultingClientId</code></dfn> attribute *must* return the value it was initialized to. When an <a>event</a> is created the attribute *must* be initialized to the empty string.
    </section>

    <section>
      <h4 id="fetch-event-replacesClientId">{{FetchEvent/replacesClientId|event.replacesClientId}}</h4>

      <dfn attribute for="FetchEvent"><code>replacesClientId</code></dfn> attribute *must* return the value it was initialized to. When an <a>event</a> is created the attribute *must* be initialized to the empty string.
    </section>

    <section>
      <h4 id="fetch-event-handled">{{FetchEvent/handled|event.handled}}</h4>

      <dfn attribute for="FetchEvent"><code>handled</code></dfn> attribute *must* return the value it was initialized to. When an <a>event</a> is created the attribute *must* be initialized to a pending [=promise=].
    </section>

    <section algorithm="fetch-event-respondwith">
      <h4 id="fetch-event-respondwith">{{FetchEvent/respondWith(r)|event.respondWith(r)}}</h4>

      Note: Developers can set the argument |r| with either a [=promise=] that resolves with a {{Response}} object or a {{Response}} object (which is automatically cast to a promise). Otherwise, a [=network error=] is returned to [=/Fetch=]. Renderer-side security checks about tainting for cross-origin content are tied to the types of [=filtered responses=] defined in [=/Fetch=].

      <dfn method for="FetchEvent"><code>respondWith(|r|)</code></dfn> method steps are:

        1. Let |event| be [=this=].
        1. If |event|'s [=dispatch flag=] is unset, [=throw=] an "{{InvalidStateError}}" {{DOMException}}.
        1. If |event|'s [=FetchEvent/respond-with entered flag=] is set, [=throw=] an "{{InvalidStateError}}" {{DOMException}}.
        1. [=ExtendableEvent/Add lifetime promise=] |r| to |event|.

            Note: {{FetchEvent/respondWith(r)|event.respondWith(r)}} extends the lifetime of the event by default as if {{ExtendableEvent/waitUntil()|event.waitUntil(r)}} is called.

        1. Set |event|'s [=stop propagation flag=] and [=stop immediate propagation flag=].
        1. Set |event|'s [=FetchEvent/respond-with entered flag=].
        1. Set |event|'s [=FetchEvent/wait to respond flag=].
        1. Let |targetRealm| be |event|'s [=relevant Realm=].
        1. [=Upon rejection=] of |r|:
            1. Set |event|'s [=FetchEvent/respond-with error flag=].
            1. Unset |event|'s [=FetchEvent/wait to respond flag=].
        1. [=Upon fulfillment=] of |r| with |response|:
            1. If |response| is not a {{Response}} object, then set the [=FetchEvent/respond-with error flag=].

                Note: If the [=FetchEvent/respond-with error flag=] is set, a [=network error=] is returned to [=/Fetch=] through [=Handle Fetch=] algorithm. (See the step 21.1.) Otherwise, the value |response| is returned to [=/Fetch=] through [=Handle Fetch=] algorithm. (See the step 22.1.)

            1. Else:
                1. Let |bytes| be an empty byte sequence.
                1. Let |end-of-body| be false.
                1. Let |done| be false.
                1. Let |potentialResponse| be a copy of |response|'s associated [=Response/response=], except for its [=response/body=].
                1. If |response|'s [=response/body=] is non-null, run these substeps:
                    1. Let |reader| be the result of [=ReadableStream/getting a reader=] from |response|'s [=response/body=]'s [=stream=].
                    1. Let |pullAlgorithm| be an action that runs these steps:
                        1. Let |readRequest| be a new [=read request=] with the following [=struct/items=]:
                            : [=read request/chunk steps=], given |chunk|
                            ::
                                1. Assert: |chunk| is a {{Uint8Array}}.
                                1. Append the bytes represented by |chunk| to |bytes|.
                                1. Perform ! [=DetachArrayBuffer=](|chunk|.\[[ViewedArrayBuffer]]).
                            : [=read request/close steps=]
                            ::
                                1. Set |end-of-body| to true.
                            : [=read request/error steps=]
                            ::
                                1. [=ReadableStream/error=] |newStream| with a {{TypeError}}.
                        1. [=ReadableStreamDefaultReader/Read a chunk=] from |reader| given |readRequest|.
                    1. Let |cancelAlgorithm| be an action that [=ReadableStreamDefaultReader/cancels=] |reader|.
                    1. Let |highWaterMark| be a non-negative, non-NaN number, chosen by the user agent.
                    1. Let |sizeAlgorithm| be an algorithm that accepts a [=chunk=] object and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.
                    1. Let |newStream| be the result of [=ReadableStream/creating=] a {{ReadableStream}} with <a for=ReadableStream/create><var ignore>pullAlgorithm</var></a> set to |pullAlgorithm|, <a for=ReadableStream/create><var ignore>cancelAlgorithm</var></a> set to |cancelAlgorithm|, <a for=ReadableStream/create><var ignore>highWaterMark</var></a> set to |highWaterMark|, and <a for=ReadableStream/create><var ignore>sizeAlgorithm</var></a> set to |sizeAlgorithm|, in |targetRealm|.
                    1. Set |potentialResponse|'s [=response/body=] to a new [=/body=] whose [=stream=] is |newStream|.
                    1. Run these subsubsteps repeatedly [=in parallel=] while |done| is false:
                        1. If |newStream| is [=ReadableStream/errored=], then set |done| to true.
                        1. Otherwise, if |bytes| is empty and |end-of-body| is true, then [=ReadableStream/close=] |newStream| and set |done| to true.
                        1. Otherwise, if |bytes| is not empty, run these subsubsubsteps:
                            1. Let |chunk| be a subsequence of |bytes| starting from the beginning of |bytes|.
                            1. Remove |chunk| from |bytes|.
                            1. Let |buffer| be an {{ArrayBuffer}} object created in |targetRealm| and containing |chunk|.
                            1. [=ReadableStream/Enqueue=] a {{Uint8Array}} object created in |targetRealm| and wrapping |buffer| to |newStream|.

                    Note: These substeps are meant to produce the observable equivalent of "piping" |response|'s [=response/body=]'s [=stream=] into |potentialResponse|.

                    Note: The data written by the service worker in chunks are not guaranteed to read in identical chunks by the client that receives the data. That is, the client will read the same data that was written, but it may be chunked differently by the browser.

                1. Set |event|'s [=FetchEvent/potential response=] to |potentialResponse|.
            1. Unset |event|'s [=FetchEvent/wait to respond flag=].
    </section>
  </section>

  <section>
    <h3 id="extendablemessageevent-interface">{{ExtendableMessageEvent}}</h3>

    <pre class="idl">
      [Exposed=ServiceWorker]
      interface ExtendableMessageEvent : ExtendableEvent {
        constructor(DOMString type, optional ExtendableMessageEventInit eventInitDict = {});
        readonly attribute any data;
        readonly attribute USVString origin;
        readonly attribute DOMString lastEventId;
        [SameObject] readonly attribute (Client or ServiceWorker or MessagePort)? source;
        readonly attribute FrozenArray&lt;MessagePort&gt; ports;
      };
    </pre>
    <pre class="idl" id="extendablemessage-event-init-dictionary">
      dictionary ExtendableMessageEventInit : ExtendableEventInit {
        any data = null;
        USVString origin = "";
        DOMString lastEventId = "";
        (Client or ServiceWorker or MessagePort)? source = null;
        sequence&lt;MessagePort&gt; ports = [];
      };
    </pre>

    [=/Service workers=] define the <a method lt="waitUntil()" for="ExtendableEvent">extendable</a> {{message!!event}} event to allow extending the lifetime of the event. For the {{message!!event}} event, [=/service workers=] use the {{ExtendableMessageEvent}} interface which extends the {{ExtendableEvent}} interface.

    <section>
      <h4 id="extendablemessage-event-data">{{ExtendableMessageEvent/data|event.data}}</h4>

      The <dfn attribute for="ExtendableMessageEvent">data</dfn> attribute *must* return the value it was initialized to. When the object is created, this attribute *must* be initialized to null. It represents the message being sent.
    </section>

    <section>
      <h4 id="extendablemessage-event-origin">{{ExtendableMessageEvent/origin|event.origin}}</h4>

      The <dfn attribute for="ExtendableMessageEvent">origin</dfn> attribute *must* return the value it was initialized to. When the object is created, this attribute *must* be initialized to the empty string. It represents the [=environment settings object/origin=] of the [=/service worker client=] that sent the message.
    </section>

    <section>
      <h4 id="extendablemessage-event-lasteventid">{{ExtendableMessageEvent/lastEventId|event.lastEventId}}</h4>

      The <dfn attribute for="ExtendableMessageEvent">lastEventId</dfn> attribute *must* return the value it was initialized to. When the object is created, this attribute *must* be initialized to the empty string.
    </section>

    <section>
      <h4 id="extendablemessage-event-source">{{ExtendableMessageEvent/source|event.source}}</h4>

      The <dfn attribute for="ExtendableMessageEvent">source</dfn> attribute *must* return the value it was initialized to. When the object is created, this attribute *must* be initialized to null. It represents the {{Client}} object from which the message is sent.
    </section>

    <section>
      <h4 id="extendablemessage-event-ports">{{ExtendableMessageEvent/ports|event.ports}}</h4>

      The <dfn attribute for="ExtendableMessageEvent">ports</dfn> attribute *must* return the value it was initialized to. When the object is created, this attribute *must* be initialized to the empty array. It represents the {{MessagePort}} array being sent.
    </section>
  </section>

  <section>
    <h3 id="execution-context-events">Events</h3>

    The following events, called [=service worker events=], are dispatched on {{ServiceWorkerGlobalScope}} object:

    <table class="data" dfn-for="ServiceWorkerGlobalScope">
      <thead>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Category</th>
          <th>Dispatched when&mldr;</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><dfn event id="service-worker-global-scope-install-event"><code>install</code></dfn></td>
          <td>{{ExtendableEvent}}</td>
          <td>[=Lifecycle Event|Lifecycle=]</td>
          <td>The [=ServiceWorkerGlobalScope/service worker=]'s <a>containing service worker registration</a>'s <a>installing worker</a> changes. (See step 11.2 of the <a>Install</a> algorithm.)</td>
        </tr>
        <tr>
          <td><dfn event id="service-worker-global-scope-activate-event"><code>activate</code></dfn></td>
          <td>{{ExtendableEvent}}</td>
          <td>[=Lifecycle Event|Lifecycle=]</td>
          <td>The [=ServiceWorkerGlobalScope/service worker=]'s <a>containing service worker registration</a>'s <a>active worker</a> changes. (See step 12.2 of the <a>Activate</a> algorithm.)</td>
        </tr>
        <tr>
          <td><dfn event id="service-worker-global-scope-fetch-event"><code>fetch</code></dfn></td>
          <td>{{FetchEvent}}</td>
          <td>[=Functional event|Functional=]</td>
          <td>The [=/http fetch=] invokes <a>Handle Fetch</a> with |request|. As a result of performing <a>Handle Fetch</a>, the [=ServiceWorkerGlobalScope/service worker=] returns a [=/response=] to the [=/http fetch=]. The [=/response=], represented by a {{Response}} object, can be retrieved from a {{Cache}} object or directly from network using {{WindowOrWorkerGlobalScope/fetch(input, init)|self.fetch(input, init)}} method. (A custom {{Response}} object can be another option.)</td>
        </tr>
        <tr>
          <td><a href="https://w3c.github.io/push-api/#dfn-push">push</a></td>
          <td><a href="https://w3c.github.io/push-api/#dom-pushevent"><code>PushEvent</code></a></td>
          <td>[=Functional event|Functional=]</td>
          <td>(See <a href="https://w3c.github.io/push-api/#dfn-fire-the-push-event">Firing a push event</a>.)</td>
        </tr>
        <tr>
          <td><a href="https://notifications.spec.whatwg.org/#dom-serviceworkerglobalscope-onnotificationclick">notificationclick</a></td>
          <td><a href="https://notifications.spec.whatwg.org/#notificationevent"><code>NotificationEvent</code></a></td>
          <td>[=Functional event|Functional=]</td>
          <td>(See <a href="https://notifications.spec.whatwg.org/#activating-a-notification">Activating a notification.</a>)</td>
        </tr>
        <tr>
          <td><a href="https://notifications.spec.whatwg.org/#dom-serviceworkerglobalscope-onnotificationclose">notificationclose</a></td>
          <td><a href="https://notifications.spec.whatwg.org/#notificationevent"><code>NotificationEvent</code></a></td>
          <td>[=Functional event|Functional=]</td>
          <td>(See <a href="https://notifications.spec.whatwg.org/#closing-a-notification">Closing a notification.</a>)</td>
        </tr>
        <tr>
          <td><a href="https://wicg.github.io/BackgroundSync/spec/#sync">sync</a></td>
          <td><a href="https://wicg.github.io/BackgroundSync/spec/#syncevent"><code>SyncEvent</code></a></td>
          <td>[=Functional event|Functional=]</td>
          <td>(See <a href="https://wicg.github.io/BackgroundSync/spec/#fire-a-sync-event">Firing a sync event</a>.)</td>
        </tr>
        <tr>
          <td><a href="https://w3c.github.io/payment-handler/#the-canmakepaymentevent">canmakepayment</a></td>
          <td><a href="https://w3c.github.io/payment-handler/#dom-canmakepaymentevent">CanMakePaymentEvent</a></td>
          <td>[=Functional event|Functional=]</td>
          <td>(See <a href="https://w3c.github.io/payment-handler/#dfn-handling-a-canmakepaymentevent">Handling a CanMakePaymentEvent</a>.)</td>
        </tr>
        <tr>
          <td><a href="https://w3c.github.io/payment-handler/#the-paymentrequestevent">paymentrequest</a></td>
          <td><a href="https://w3c.github.io/payment-handler/#dom-paymentrequestevent">PaymentRequestEvent</a></td>
          <td>[=Functional event|Functional=]</td>
          <td>(See <a href="https://w3c.github.io/payment-handler/#dfn-handling-a-paymentrequestevent">Handling a PaymentRequestEvent</a>.)</td>
        </tr>
        <tr>
          <td><dfn event><code>message</code></dfn></td>
          <td>{{ExtendableMessageEvent}}</td>
          <td>Legacy</td>
          <td>When it receives a message.</td>
        </tr>
        <tr>
          <td><dfn event><code>messageerror</code></dfn></td>
          <td>{{MessageEvent}}</td>
          <td>Legacy</td>
          <td>When it was sent a message that cannot be deserialized.</td>
        </tr>
      </tbody>
    </table>
  </section>
</section>

<section>
  <h2 id="cache-objects">Caches</h2>

  To allow authors to fully manage their content caches for offline use, the {{Window}} and the {{WorkerGlobalScope}} provide the asynchronous caching methods that open and manipulate {{Cache}} objects. An [=environment settings object/origin=] can have multiple, named {{Cache}} objects, whose contents are entirely under the control of scripts. Caches are not shared across [=/origins=], and they are completely isolated from the browser's HTTP cache.

  <section>
    <h3 id="cache-constructs">Constructs</h3>

    A <dfn id="dfn-request-response-list">request response list</dfn> is a [=list=] of [=pairs=] consisting of a request (a [=/request=]) and a response (a [=/response=]).

    The <dfn id="dfn-relevant-request-response-list">relevant request response list</dfn> is the instance that [=this=] represents.

    A <dfn id="dfn-name-to-cache-map">name to cache map</dfn> is an <a>ordered map</a> whose [=map/entry=] consists of a [=map/key=] (a string that represents the name of a [=request response list=]) and a [=map/value=] (a [=request response list=]).

    Each [=/origin=] has an associated [=name to cache map=].

    The <dfn id="dfn-relevant-name-to-cache-map">relevant name to cache map</dfn> is the instance of [=this=]'s associated [=CacheStorage/global object=]'s [=environment settings object=]'s [=environment settings object/origin=].
  </section>

  <section>
    <h3 id="cache-lifetimes">Understanding Cache Lifetimes</h3>

    The {{Cache}} instances are not part of the browser's HTTP cache. The {{Cache}} objects are exactly what authors have to manage themselves. The {{Cache}} objects do not get updated unless authors explicitly request them to be. The {{Cache}} objects do not expire unless authors delete the entries. The {{Cache}} objects do not disappear just because the [=/service worker=] script is updated. That is, caches are not updated automatically. Updates must be manually managed. This implies that authors should version their caches by name and make sure to use the caches only from the version of the [=/service worker=] that can safely operate on.
  </section>

  <section>
    <h3 id="self-caches">{{WindowOrWorkerGlobalScope/caches|self.caches}}</h3>

    <pre class="idl">
      partial interface mixin WindowOrWorkerGlobalScope {
        [SecureContext, SameObject] readonly attribute CacheStorage caches;
      };
    </pre>

    <section>
      <h4 id="global-caches">{{WindowOrWorkerGlobalScope/caches}}</h4>

      <dfn attribute for="WindowOrWorkerGlobalScope" id="global-caches-attribute"><code>caches</code></dfn> getter steps are to return [=this=]'s associated {{CacheStorage}} object.
    </section>
  </section>

  <section>
    <h3 id="cache-interface">{{Cache}}</h3>

    <pre class="idl">
      [SecureContext, Exposed=(Window,Worker)]
      interface Cache {
        [NewObject] Promise&lt;(Response or undefined)&gt; match(RequestInfo request, optional CacheQueryOptions options = {});
        [NewObject] Promise&lt;FrozenArray&lt;Response&gt;&gt; matchAll(optional RequestInfo request, optional CacheQueryOptions options = {});
        [NewObject] Promise&lt;undefined&gt; add(RequestInfo request);
        [NewObject] Promise&lt;undefined&gt; addAll(sequence&lt;RequestInfo&gt; requests);
        [NewObject] Promise&lt;undefined&gt; put(RequestInfo request, Response response);
        [NewObject] Promise&lt;boolean&gt; delete(RequestInfo request, optional CacheQueryOptions options = {});
        [NewObject] Promise&lt;FrozenArray&lt;Request&gt;&gt; keys(optional RequestInfo request, optional CacheQueryOptions options = {});
      };
    </pre>
    <pre class="idl" id="cache-query-options-dictionary">
      dictionary CacheQueryOptions {
        boolean ignoreSearch = false;
        boolean ignoreMethod = false;
        boolean ignoreVary = false;
      };
    </pre>

    A {{Cache}} object represents a [=request response list=]. Multiple separate objects implementing the {{Cache}} interface across documents and workers can all be associated with the same [=request response list=] simultaneously.

    A <dfn export id="dfn-cache-batch-operation">cache batch operation</dfn> is a [=struct=] that consists of:
      * A <dfn export id="dfn-cache-batch-operation-type" for="cache batch operation">type</dfn> ("`delete`" or "`put`").
      * A <dfn export id="dfn-cache-batch-operation-request" for="cache batch operation">request</dfn> (a [=/request=]).
      * A <dfn export id="dfn-cache-batch-operation-response" for="cache batch operation">response</dfn> (a [=/response=]).
      * An <dfn export id="dfn-cache-batch-operation-options" for="cache batch operation">options</dfn> (a {{CacheQueryOptions}}).

    <section algorithm="cache-match">
      <h4 id="cache-match">{{Cache/match(request, options)}}</h4>

      The <dfn method for="Cache"><code>match(|request|, |options|)</code></dfn> method steps are:

        1. Let |promise| be [=a new promise=].
        1. Run these substeps [=in parallel=]:
            1. Let |p| be the result of running the algorithm specified in {{Cache/matchAll(request, options)}} method with |request| and |options|.
            1. Wait until |p| settles.
            1. If |p| rejects with an exception, then:
                1. Reject |promise| with that exception.
            1. Else if |p| resolves with an array, |responses|, then:
                1. If |responses| is an empty array, then:
                    1. Resolve |promise| with undefined.
                1. Else:
                    1. Resolve |promise| with the first element of |responses|.
        1. Return |promise|.
    </section>

    <section algorithm="cache-matchall">
      <h4 id="cache-matchall">{{Cache/matchAll(request, options)}}</h4>

      The <dfn method for="Cache"><code>matchAll(|request|, |options|)</code></dfn> method steps are:

        1. Let |r| be null.
        1. If the optional argument |request| is not omitted, then:
            1. If |request| is a {{Request}} object, then:
                1. Set |r| to |request|'s [=Request/request=].
                1. If |r|'s [=request/method=] is not \`<code>GET</code>\` and |options|.ignoreMethod is false, return [=a promise resolved with=] an empty array.
            1. Else if |request| is a string, then:
                1. Set |r| to the associated [=Request/request=] of the result of invoking the initial value of {{Request}} as constructor with |request| as its argument. If this [=throws=] an exception, return [=a promise rejected with=] that exception.
        1. Let |realm| be [=this=]'s [=relevant realm=].
        1. Let |promise| be [=a new promise=].
        1. Run these substeps [=in parallel=]:
            1. Let |responses| be an empty [=list=].
            1. If the optional argument |request| is omitted, then:
                1. [=list/For each=] |requestResponse| of the [=relevant request response list=]:
                    1. Add a copy of |requestResponse|'s response to |responses|.
            1. Else:
                1. Let |requestResponses| be the result of running [=Query Cache=] with |r| and |options|.
                1. [=list/For each=] |requestResponse| of |requestResponses|:
                    1. Add a copy of |requestResponse|'s response to |responses|.
            1. [=list/For each=] |response| of |responses|:
                1. If |response|'s [=response/type=] is "`opaque`" and [=cross-origin resource policy check=] with |promise|'s [=relevant settings object=]'s [=environment settings object/origin=], |promise|'s [=relevant settings object=], "", and |response|'s [=internal/internal response=] returns <b>blocked</b>, then reject |promise| with a `TypeError` and abort these steps.
            1. [=Queue a task=], on |promise|'s [=relevant settings object=]'s [=responsible event loop=] using the [=DOM manipulation task source=], to perform the following steps:
                1. Let |responseList| be a [=list=].
                1. [=list/For each=] |response| of |responses|:
                    1. Add a new {{Response}} object associated with |response| and a new {{Headers}} object whose <a>guard</a> is "<code>immutable</code>" to |responseList|.
                1. Resolve |promise| with a [=frozen array type|frozen array=] [=create a frozen array|created=] from |responseList|, in |realm|.
        1. Return |promise|.
    </section>

    <section algorithm="cache-add">
      <h4 id="cache-add">{{Cache/add(request)}}</h4>

      The <dfn method for="Cache"><code>add(|request|)</code></dfn> method steps are:

        1. Let |requests| be an array containing only |request|.
        1. Let |responseArrayPromise| be the result of running the algorithm specified in {{Cache/addAll(requests)}} passing |requests| as the argument.
        1. Return the result of [=promise/reacting=] to |responseArrayPromise| with a fulfillment handler that returns undefined.
    </section>

    <section algorithm="cache-addAll">
      <h4 id="cache-addAll">{{Cache/addAll(requests)}}</h4>

      The <dfn method for="Cache"><code>addAll(|requests|)</code></dfn> method steps are:

        1. Let |responsePromises| be an empty [=list=].
        1. Let |requestList| be an empty [=list=].
        1. For each |request| whose type is {{Request}} in |requests|:
            1. Let |r| be |request|'s [=Request/request=].
            1. If |r|'s [=request/url=]'s [=url/scheme=] is not one of "`http`" and "`https`", or |r|'s [=request/method=] is not \``GET`\`, return [=a promise rejected with=] a `TypeError`.
        1. For each |request| in |requests|:
            1. Let |r| be the associated [=Request/request=] of the result of invoking the initial value of {{Request}} as constructor with |request| as its argument. If this <a>throws</a> an exception, return [=a promise rejected with=] that exception.
            1. If |r|'s [=request/url=]'s [=url/scheme=] is not one of "<code>http</code>" and "<code>https</code>", then:
                1. [=fetch/Terminate=] all the ongoing [=fetches=] initiated by |requests| with the aborted flag set.
                1. Return [=a promise rejected with=] a `TypeError`.
            1. If |r|'s [=request/client=]'s [=environment settings object/global object=] is a {{ServiceWorkerGlobalScope}} object, set |request|'s [=service-workers mode=] to "`none`".
            1. Set |r|'s [=request/initiator=] to "`fetch`" and [=request/destination=] to "`subresource`".
            1. Add |r| to |requestList|.
            1. Let |responsePromise| be [=a new promise=].
            1. Run the following substeps [=in parallel=]:
                * [=/Fetch=] |r|.
                * To [=process response=] for |response|, run these substeps:
                    1. If |response|'s [=response/type=] is "<code>error</code>", or |response|'s [=response/status=] is not an [=ok status=] or is `206`, reject |responsePromise| with a `TypeError`.
                    1. Else if |response|'s [=response/header list=] contains a [=header=] [=header/named=] \``Vary`\`, then:
                        1. Let |fieldValues| be the [=list=] containing the elements corresponding to the [=http/field-values=] of the [=Vary=] header.
                        1. [=list/For each=] |fieldValue| of |fieldValues|:
                            1. If |fieldValue| matches "`*`", then:
                                1. Reject |responsePromise| with a `TypeError`.
                                1. [=fetch/Terminate=] all the ongoing [=fetches=] initiated by |requests| with the aborted flag set.
                                1. Abort these steps.

                * To [=process response end-of-body=] for |response|, run these substeps:
                    1. If |response|'s [=response/aborted flag=] is set, reject |responsePromise| with an "{{AbortError}}" {{DOMException}} and abort these steps.
                    1. Resolve |responsePromise| with |response|.

                    Note: The cache commit is allowed when the response's body is fully received.

            1. Add |responsePromise| to |responsePromises|.
        1. Let |p| be the result of [=getting a promise to wait for all=] of |responsePromises|.
        1. Return the result of [=promise/reacting=] to |p| with a fulfillment handler that, when called with argument |responses|, performs the following substeps:
            1. Let |operations| be an empty [=list=].
            1. Let |index| be zero.
            1. For each |response| in |responses|:
                1. Let |operation| be a [=cache batch operation=].
                1. Set |operation|'s [=cache batch operation/type=] to "`put`".
                1. Set |operation|'s [=cache batch operation/request=] to |requestList|[|index|].
                1. Set |operation|'s [=cache batch operation/response=] to |response|.
                1. [=list/Append=] |operation| to |operations|.
                1. Increment |index| by one.
            1. Let |realm| be [=this=]'s [=relevant realm=].
            1. Let |cacheJobPromise| be [=a new promise=].
            1. Run the following substeps [=in parallel=]:
                1. Let |errorData| be null.
                1. Invoke [=Batch Cache Operations=] with |operations|. If this [=throws=] an exception, set |errorData| to the exception.
                1. [=Queue a task=], on |cacheJobPromise|'s [=relevant settings object=]'s [=responsible event loop=] using the [=DOM manipulation task source=], to perform the following substeps:
                    1. If |errorData| is null, resolve |cacheJobPromise| with undefined.
                    1. Else, reject |cacheJobPromise| with a [=exception/create|new=] [=exception=] with |errorData| and a user agent-defined [=exception/message=], in |realm|.
            1. Return |cacheJobPromise|.
    </section>

    <section algorithm="cache-put">
      <h4 id="cache-put">{{Cache/put(request, response)}}</h4>

      The <dfn method for="Cache"><code>put(|request|, |response|)</code></dfn> method steps are:

        1. Let |innerRequest| be null.
        1. If |request| is a {{Request}} object, then set |innerRequest| to |request|'s [=Request/request=].
        1. Else:
            1. Let |requestObj| be the result of invoking {{Request}}'s constructor with |request| as its argument. If this [=throws=] an |exception|, return [=a promise rejected with=] |exception|.
            1. Set |innerRequest| to |requestObj|'s [=Request/request=].
        1. If |innerRequest|'s [=request/url=]'s [=url/scheme=] is not one of "`http`" and "`https`", or |innerRequest|'s [=request/method=] is not \`<code>GET</code>\`, return [=a promise rejected with=] a `TypeError`.
        1. Let |innerResponse| be |response|'s [=Response/response=].
        1. If |innerResponse|'s [=response/status=] is `206`, return [=a promise rejected with=] a `TypeError`.
        1. If |innerResponse|'s [=response/header list=] contains a [=header=] [=header/named=] \``Vary`\`, then:
            1. Let |fieldValues| be the [=list=] containing the [=list/items=] corresponding to the  [=Vary=] header's [=http/field-values=].
            1. [=list/For each=] |fieldValue| in |fieldValues|:
                1. If |fieldValue| matches "`*`", return [=a promise rejected with=] a `TypeError`.
        1. If |innerResponse|'s [=response/body=] is [=Body/disturbed=] or [=Body/locked=], return [=a promise rejected with=] a `TypeError`.
        1. Let |clonedResponse| be a [=response/clone=] of |innerResponse|.
        1. Let |bodyReadPromise| be [=a promise resolved with=] undefined.
        1. If |innerResponse|'s [=response/body=] is non-null, run these substeps:
            1. Let |stream| be |innerResponse|'s [=response/body=]'s [=body/stream=].
            1. Let |reader| be the result of [=ReadableStream/getting a reader=] for |stream|.
            1. Set |bodyReadPromise| to the result of [=ReadableStreamDefaultReader/reading all bytes=] from |reader|.

            Note: This ensures that |innerResponse|'s [=response/body=] is [=Body/locked=], and we have a full buffered copy of the body in |clonedResponse|. An implementation could optimize by streaming directly to disk rather than memory.

        1. Let |operations| be an empty [=list=].
        1. Let |operation| be a [=cache batch operation=].
        1. Set |operation|'s [=cache batch operation/type=] to "`put`".
        1. Set |operation|'s [=cache batch operation/request=] to |innerRequest|.
        1. Set |operation|'s [=cache batch operation/response=] to |clonedResponse|.
        1. [=list/Append=] |operation| to |operations|.
        1. Let |realm| be [=this=]'s [=relevant realm=].
        1. Return the result of the [=Upon fulfillment|fulfillment=] of |bodyReadPromise|:
            1. Let |cacheJobPromise| be [=a new promise=].
            1. Return |cacheJobPromise| and run these steps [=in parallel=]:
                1. Let |errorData| be null.
                1. Invoke [=Batch Cache Operations=] with |operations|. If this [=throws=] an exception, set |errorData| to the exception.
                1. [=Queue a task=], on |cacheJobPromise|'s [=relevant settings object=]'s [=responsible event loop=] using the [=DOM manipulation task source=], to perform the following substeps:
                    1. If |errorData| is null, resolve |cacheJobPromise| with undefined.
                    1. Else, reject |cacheJobPromise| with a [=exception/create|new=] [=exception=] with |errorData| and a user agent-defined [=exception/message=], in |realm|.
    </section>

    <section algorithm="cache-delete">
      <h4 id="cache-delete">{{Cache/delete(request, options)}}</h4>

      The <dfn method for="Cache"><code>delete(|request|, |options|)</code></dfn> method steps are:

        1. Let |r| be null.
        1. If |request| is a {{Request}} object, then:
            1. Set |r| to |request|'s [=Request/request=].
            1. If |r|'s [=request/method=] is not \`<code>GET</code>\` and |options|.ignoreMethod is false, return [=a promise resolved with=] false.
        1. Else if |request| is a string, then:
            1. Set |r| to the associated [=Request/request=] of the result of invoking the initial value of {{Request}} as constructor with |request| as its argument. If this [=throws=] an exception, return [=a promise rejected with=] that exception.
        1. Let |operations| be an empty [=list=].
        1. Let |operation| be a [=cache batch operation=].
        1. Set |operation|'s [=cache batch operation/type=] to "`delete`".
        1. Set |operation|'s [=cache batch operation/request=] to |r|.
        1. Set |operation|'s [=cache batch operation/options=] to |options|.
        1. [=list/Append=] |operation| to |operations|.
        1. Let |realm| be [=this=]'s [=relevant realm=].
        1. Let |cacheJobPromise| be [=a new promise=].
        1. Run the following substeps [=in parallel=]:
            1. Let |errorData| be null.
            1. Let |requestResponses| be the result of running [=Batch Cache Operations=] with |operations|. If this [=throws=] an exception, set |errorData| to the exception.
            1. [=Queue a task=], on |cacheJobPromise|'s [=relevant settings object=]'s [=responsible event loop=] using the [=DOM manipulation task source=], to perform the following substeps:
                1. If |errorData| is null, then:
                    1. If |requestResponses| [=list/is not empty=], resolve |cacheJobPromise| with true.
                    1. Else, resolve |cacheJobPromise| with false.
                1. Else, reject |cacheJobPromise| with a [=exception/create|new=] [=exception=] with |errorData| and a user agent-defined [=exception/message=], in |realm|.
        1. Return |cacheJobPromise|.
    </section>

    <section algorithm="cache-keys">
      <h4 id="cache-keys">{{Cache/keys(request, options)}}</h4>

      The <dfn method for="Cache"><code>keys(|request|, |options|)</code></dfn> method steps are:

        1. Let |r| be null.
        1. If the optional argument |request| is not omitted, then:
            1. If |request| is a {{Request}} object, then:
                1. Set |r| to |request|'s [=Request/request=].
                1. If |r|'s [=request/method=] is not \`<code>GET</code>\` and |options|.ignoreMethod is false, return [=a promise resolved with=] an empty array.
            1. Else if |request| is a string, then:
                1. Set |r| to the associated [=Request/request=] of the result of invoking the initial value of {{Request}} as constructor with |request| as its argument. If this [=throws=] an exception, return [=a promise rejected with=] that exception.
        1. Let |realm| be [=this=]'s [=relevant realm=].
        1. Let |promise| be [=a new promise=].
        1. Run these substeps [=in parallel=]:
            1. Let |requests| be an empty [=list=].
            1. If the optional argument |request| is omitted, then:
                1. [=list/For each=] |requestResponse| of the [=relevant request response list=]:
                    1. Add |requestResponse|'s request to |requests|.
            1. Else:
                1. Let |requestResponses| be the result of running [=Query Cache=] with |r| and |options|.
                1. [=list/For each=] |requestResponse| of |requestResponses|:
                    1. Add |requestResponse|'s request to |requests|.
            1. [=Queue a task=], on |promise|'s [=relevant settings object=]'s [=responsible event loop=] using the [=DOM manipulation task source=], to perform the following steps:
                1. Let |requestList| be a [=list=].
                1. [=list/For each=] |request| of |requests|:
                    1. Add a new {{Request}} object associated with |request| and a new associated {{Headers}} object whose [=guard=] is "`immutable`" to |requestList|.
                1. Resolve |promise| with a [=frozen array type|frozen array=] [=create a frozen array|created=] from |requestList|, in |realm|.
        1. Return |promise|.
    </section>
  </section>

  <section>
    <h3 id="cachestorage-interface">{{CacheStorage}}</h3>

    <pre class="idl">
      [SecureContext, Exposed=(Window,Worker)]
      interface CacheStorage {
        [NewObject] Promise&lt;(Response or undefined)&gt; match(RequestInfo request, optional MultiCacheQueryOptions options = {});
        [NewObject] Promise&lt;boolean&gt; has(DOMString cacheName);
        [NewObject] Promise&lt;Cache&gt; open(DOMString cacheName);
        [NewObject] Promise&lt;boolean&gt; delete(DOMString cacheName);
        [NewObject] Promise&lt;sequence&lt;DOMString&gt;&gt; keys();
      };

      dictionary MultiCacheQueryOptions : CacheQueryOptions {
        DOMString cacheName;
      };
    </pre>
    <!--FIXME(jungkees): set method is not entirely dropped yet. Promise&lt;any&gt; set(DOMString key, Cache val);-->

    Note: {{CacheStorage}} interface is designed to largely conform to <a lt="map objects">ECMAScript 6 Map objects</a> but entirely async, and with additional convenience methods. The methods, <code>clear</code>, <code>forEach</code>, <code>entries</code> and <code>values</code>, are intentionally excluded from the scope of the first version resorting to the ongoing discussion about the async iteration by TC39.

    The user agent *must* create a {{CacheStorage}} object when a {{Window}} object or a {{WorkerGlobalScope}} object is created and associate it with that <dfn for="CacheStorage">global object</dfn>.

    A {{CacheStorage}} object represents a <a>name to cache map</a> of its associated [=CacheStorage/global object=]'s <a>environment settings object</a>'s [=environment settings object/origin=]. Multiple separate objects implementing the {{CacheStorage}} interface across documents and workers can all be associated with the same <a>name to cache map</a> simultaneously.

    <section algorithm="cache-storage-match">
      <h4 id="cache-storage-match">{{CacheStorage/match(request, options)}}</h4>

      The <dfn method for="CacheStorage"><code>match(|request|, |options|)</code></dfn> method steps are:

        1. If |options|["{{MultiCacheQueryOptions/cacheName}}"] [=map/exists=], then:
            1. Return [=a new promise=] |promise| and run the following substeps [=in parallel=]:
                1. [=map/For each=] |cacheName| → |cache| of the [=relevant name to cache map=]:
                    1. If |options|["{{MultiCacheQueryOptions/cacheName}}"] matches |cacheName|, then:
                        1. Resolve |promise| with the result of running the algorithm specified in {{Cache/match(request, options)}} method of {{Cache}} interface with |request| and |options| (providing |cache| as thisArgument to the `[[Call]]` internal method of {{Cache/match(request, options)}}.)
                        1. Abort these steps.
                1. Resolve |promise| with undefined.
        1. Else:
            1. Let |promise| be [=a promise resolved with=] undefined.
            1. [=map/For each=] <var ignore>cacheName</var> → |cache| of the [=relevant name to cache map=]:
                1. Set |promise| to the result of [=promise/reacting=] to itself with a fulfillment handler that, when called with argument |response|, performs the following substeps:
                    1. If |response| is not undefined, return |response|.
                    1. Return the result of running the algorithm specified in {{Cache/match(request, options)}} method of {{Cache}} interface with |request| and |options| as the arguments (providing |cache| as thisArgument to the `[[Call]]` internal method of {{Cache/match(request, options)}}.)
            1. Return |promise|.
    </section>

    <section algorithm="cache-storage-has">
      <h4 id="cache-storage-has">{{CacheStorage/has(cacheName)}}</h4>

      The <dfn method for="CacheStorage"><code>has(|cacheName|)</code></dfn> method steps are:

        1. Let |promise| be [=a new promise=].
        1. Run the following substeps [=in parallel=]:
            1. [=map/For each=] |key| → <var ignore>value</var> of the [=relevant name to cache map=]:
                1. If |cacheName| matches |key|, resolve |promise| with true and abort these steps.
            1. Resolve |promise| with false.
        1. Return |promise|.
    </section>

    <section algorithm="cache-storage-open">
      <h4 id="cache-storage-open">{{CacheStorage/open(cacheName)}}</h4>

      The <dfn method for="CacheStorage"><code>open(|cacheName|)</code></dfn> method steps are:

        1. Let |promise| be [=a new promise=].
        1. Run the following substeps [=in parallel=]:
            1. [=map/For each=] |key| → |value| of the [=relevant name to cache map=]:
                1. If |cacheName| matches |key|, then:
                    1. Resolve |promise| with a new {{Cache}} object that represents |value|.
                    1. Abort these steps.
            1. Let |cache| be a new [=request response list=].
            1. [=map/Set=] the [=relevant name to cache map=][|cacheName|] to |cache|. If this cache write operation failed due to exceeding the granted quota limit, reject |promise| with a "{{QuotaExceededError}}" {{DOMException}} and abort these steps.
            1. Resolve |promise| with a new {{Cache}} object that represents |cache|.
        1. Return |promise|.
    </section>

    <section algorithm="cache-storage-delete">
      <h4 id="cache-storage-delete">{{CacheStorage/delete(cacheName)}}</h4>

      The <dfn method for="CacheStorage"><code>delete(|cacheName|)</code></dfn> method steps are:

        1. Let |promise| be the result of running the algorithm specified in {{CacheStorage/has(cacheName)}} method with |cacheName|.
        1. Return the result of [=promise/reacting=] to |promise| with a fulfillment handler that, when called with argument |cacheExists|, performs the following substeps:
            1. If |cacheExists| is false, then:
                1. Return false.
            1. Let |cacheJobPromise| be [=a new promise=].
            1. Run the following substeps [=in parallel=]:
                1. [=map/Remove=] the [=relevant name to cache map=][|cacheName|].
                1. Resolve |cacheJobPromise| with true.

                Note: After this step, the existing DOM objects (i.e. the currently referenced Cache, Request, and Response objects) should remain functional.

            1. Return |cacheJobPromise|.
    </section>

    <section algorithm="cache-storage-keys">
      <h4 id="cache-storage-keys">{{CacheStorage/keys()}}</h4>

      The <dfn method for="CacheStorage"><code>keys()</code></dfn> method steps are:

        1. Let |promise| be [=a new promise=].
        1. Run the following substeps [=in parallel=]:
            1. Let |cacheKeys| be the result of [=map/get the keys|getting the keys=] of the [=relevant name to cache map=].

                Note: The [=list/items=] in the result [=ordered set=] are in the order that their corresponding entry was added to the [=name to cache map=].

            1. Resolve |promise| with |cacheKeys|.
        1. Return |promise|.
    </section>
  </section>
</section>

<section>
  <h2 id="security-considerations">Security Considerations</h2>

  <section>
    <h3 id="secure-context">Secure Context</h3>

    [=/Service workers=] *must* execute in <a>secure contexts</a>. [=/Service worker clients=] *must* also be <a>secure contexts</a> to register a [=/service worker registration=], to get access to the [=/service worker registrations=] and the [=/service workers=], to do messaging with the [=/service workers=], and to be manipulated by the [=/service workers=].

    Note: This effectively means that [=/service workers=] and their [=/service worker clients=] need to be hosted over HTTPS. A user agent can allow <code>localhost</code> (see <a href="https://w3c.github.io/webappsec-secure-contexts/#localhost">the requirements</a>), <code>127.0.0.0/8</code>, and <code>::1/128</code> for development purposes. The primary reason for this restriction is to protect users from the <a href="https://w3c.github.io/webappsec-secure-contexts/#threat-risks">risks associated with insecure contexts</a>.
  </section>

  <section>
    <h3 id="content-security-policy">Content Security Policy</h3>

    Whenever a user agent invokes the [=Run Service Worker=] algorithm with a [=/service worker=] |serviceWorker|:

      * If |serviceWorker|'s <a>script resource</a> was delivered with a <code>Content-Security-Policy</code> HTTP header containing the value |policy|, the user agent *must* <a>enforce</a> |policy| for |serviceWorker|.
      * If |serviceWorker|'s <a>script resource</a> was delivered with a <code>Content-Security-Policy-Report-Only</code> HTTP header containing the value |policy|, the user agent *must* <a>monitor</a> |policy| for |serviceWorker|.

    The primary reason for this restriction is to mitigate a broad class of content injection vulnerabilities, such as cross-site scripting (XSS).
  </section>

  <section>
    <h3 id="origin-relativity">Origin Relativity</h3>

    <section>
      <h4 id="origin-restriction">Origin restriction</h4>

      *This section is non-normative.*

      A [=/service worker=] executes in the registering [=/service worker client=]'s [=environment settings object/origin=]. One of the advanced concerns that major applications would encounter is whether they can be hosted from a CDN. By definition, these are servers in other places, often on other [=/origins=]. Therefore, [=/service workers=] cannot be hosted on CDNs. But they can include resources via <a>importScripts()</a>. The reason for this restriction is that [=/service workers=] create the opportunity for a bad actor to turn a bad day into a bad eternity.
    </section>

    <section>
      <h4 id="importscripts">{{WorkerGlobalScope/importScripts(urls)}}</h4>

      When the <dfn method for="ServiceWorkerGlobalScope" id="importscripts-method"><code>importScripts(|urls|)</code></dfn> method is called on a {{ServiceWorkerGlobalScope}} object, the user agent *must* <a>import scripts into worker global scope</a>, given this {{ServiceWorkerGlobalScope}} object and |urls|, and with the following steps to [=fetching scripts/perform the fetch=] given the [=/request=] |request|:

        1. Let |serviceWorker| be |request|'s [=request/client=]'s [=environment settings object/global object=]'s [=ServiceWorkerGlobalScope/service worker=].
        1. Let |map| be |serviceWorker|'s [=script resource map=].
        1. Let |url| be |request|'s [=request/url=].
        1. If |serviceWorker|'s [=state=] is not "`parsed`" or "`installing`":
            1. Return |map|[|url|] if it [=map/exists=] and a [=network error=] otherwise.
        1. If |map|[|url|] [=map/exists=]:
            1. [=set/Append=] |url| to |serviceWorker|'s [=set of used scripts=].
            1. Return |map|[|url|].
        1. Let |registration| be |serviceWorker|'s [=containing service worker registration=].
        1. Set |request|'s [=service-workers mode=] to "`none`".
        1. Set |request|'s [=request/cache mode=] to "`no-cache`" if any of the following are true:
            * |registration|'s [=service worker registration/update via cache mode=] is "`none`".
            * The [=current global object=]'s [=force bypass cache for import scripts flag=] is set.
            * |registration| is [=stale=].
        1. Let |response| be the result of [=fetch|fetching=] |request|.
        1. If |response|’s [=response/cache state=] is not "`local`", set |registration|’s [=service worker registration/last update check time=] to the current time.
        1. If |response|'s [=unsafe response=] is a [=bad import script response=], then return a [=network error=].
        1. [=map/Set=] |map|[|url|] to |response|.
        1. [=set/Append=] |url| to |serviceWorker|'s [=set of used scripts=].
        1. Set |serviceWorker|'s [=classic scripts imported flag=].
        1. Return |response|.
    </section>
  </section>

  <section>
    <h3 id="cross-origin-resources">Cross-Origin Resources and CORS</h3>

    *This section is non-normative.*

    Applications tend to cache items that come from a CDN or other [=environment settings object/origin=]. It is possible to request many of them directly using <code>&lt;script&gt;</code>, <code>&lt;img&gt;</code>, <code>&lt;video&gt;</code> and <code>&lt;link&gt;</code> elements. It would be hugely limiting if this sort of runtime collaboration broke when offline. Similarly, it is possible to [=/fetch=] many sorts of off-[=environment settings object/origin=] resources when appropriate CORS headers are set.
    [=/Service workers=] enable this by allowing {{Cache|Caches}} to [=/fetch=] and cache off-origin items. Some restrictions apply, however. First, unlike same-origin resources which are managed in the {{Cache}} as {{Response}} objects whose corresponding [=Response/responses=] are <a>basic filtered response</a>, the objects stored are {{Response}} objects whose corresponding [=Response/responses=] are either <a>CORS filtered responses</a> or <a>opaque filtered responses</a>. They can be passed to {{FetchEvent/respondWith(r)|event.respondWith(r)}} method in the same manner as the {{Response}} objects whose corresponding [=Response/responses=] are <a>basic filtered responses</a>, but cannot be meaningfully created programmatically. These limitations are necessary to preserve the security invariants of the platform. Allowing {{Cache|Caches}} to store them allows applications to avoid re-architecting in most cases.
  </section>

  <section>
    <h3 id="path-restriction">Path restriction</h3>

    *This section is non-normative.*

    In addition to the [[#origin-restriction|origin restriction]], service workers are restricted by the [=url/path=] of the service worker script. For example, a service worker script at <code>https://www.example.com/~bob/sw.js</code> can be registered for the [=service worker registration/scope url=] <code>https://www.example.com/~bob/</code> but not for the scope <code>https://www.example.com/</code> or <code>https://www.example.com/~alice/</code>. This provides some protection for sites that host multiple-user content in separated directories on the same origin. However, the path restriction is not considered a hard security boundary, as only origins are. Sites are encouraged to use different origins to securely isolate segments of the site if appropriate.

    Servers can remove the path restriction by setting a [=Service-Worker-Allowed=] header on the service worker script.
  </section>

  <section>
    <h3 id="script-request">Service worker script request</h3>

    *This section is non-normative.*

    To further defend against malicious registration of a service worker on a site, this specification requires that:
    * The [=Service-Worker=] header is present on service worker script requests, and
    * Service worker scripts are served with a [=JavaScript MIME type=].
  </section>

  <section>
    <h3 id="implementer-concerns">Implementer Concerns</h3>

    *This section is non-normative.*

    The implementers are encouraged to note:

      * Plug-ins should not load via [=/service workers=]. As plug-ins may get their security origins from their own urls, the embedding [=/service worker=] cannot handle it. For this reason, the <a>Handle Fetch</a> algorithm makes <code>&lt;embed&gt;</code> and <code>&lt;object&gt;</code> requests immediately fallback to the network without dispatching {{fetch!!event}} event.
      * Some of the legacy networking stack code may need to be carefully audited to understand the ramifications of interactions with [=/service workers=].
  </section>

  <section>
    <h3 id="privacy">Privacy</h3>

    [=/Service workers=] introduce new persistent storage features including <a>scope to registration map</a> (for [=/service worker registrations=] and their [=/service workers=]), [=request response list=] and <a>name to cache map</a> (for caches), and [=script resource map=] (for script resources). In order to protect users from any potential <a biblio data-biblio-type="informative" lt="unsanctioned-tracking">unsanctioned tracking</a> threat, these persistent storages *should* be cleared when users intend to clear them and *should* maintain and interoperate with existing user controls e.g. purging all existing persistent storages.
  </section>
</section>

<section>
  <h2 id="extensibility">Extensibility</h2>

  Service Workers specification is extensible from other specifications.

  <section>
    <h3 id="extension-to-service-worker-registration">Define API bound to Service Worker Registration</h3>

    Specifications *may* define an API tied to a [=/service worker registration=] by using <a>partial interface</a> definition to the {{ServiceWorkerRegistration}} interface where it *may* define the specification specific attributes and methods:

    <pre class="example idl" data-no-idl>
      partial interface ServiceWorkerRegistration {
        // e.g. define an API namespace
        readonly attribute APISpaceType APISpace;
        // e.g. define a method
        Promise&lt;T&gt; methodName(/* list of arguments */);
      };
    </pre>
  </section>

  <section>
    <h3 id="extension-to-extendable-event">Define Functional Event</h3>

    Specifications *may* define a <a>functional event</a> by extending {{ExtendableEvent}} interface:

    <pre class="example idl" data-no-idl>
      // e.g. define FunctionalEvent interface
      interface FunctionalEvent : ExtendableEvent {
        // add a functional event's own attributes and methods
      };
    </pre>
  </section>

  <section>
    <h3 id="extension-to-service-worker-global-scope">Define Event Handler</h3>

    Specifications *may* define an event handler attribute for the corresponding <a>functional event</a> using <a>partial interface</a> definition to the {{ServiceWorkerGlobalScope}} interface:

    <pre class="example idl" data-no-idl>
      partial interface ServiceWorkerGlobalScope {
        attribute EventHandler onfunctionalevent;
      };
    </pre>
  </section>

  <section>
    <h3 id="firing-functional-events">Firing Functional Events</h3>

    To request a [=functional event=] dispatch to the [=service worker registration/active worker=] of a [=/service worker registration=], specifications *should* invoke [=Fire Functional Event=].
  </section>
</section>

<section>
  <h2 id="algorithms">Appendix A: Algorithms</h2>

  The following definitions are the user agent's internal data structures used throughout the specification.

  A <dfn id="dfn-scope-to-registration-map">scope to registration map</dfn> is an <a>ordered map</a> where the keys are [=service worker registration/scope urls=], [=URL serializer|serialized=], and the values are [=/service worker registrations=].

  A <dfn id="dfn-job">job</dfn> is an abstraction of one of register, update, and unregister request for a [=/service worker registration=].

  <div dfn-for="job">
    A <a>job</a> has a <dfn id="dfn-job-type">job type</dfn>, which is one of *register*, *update*, and *unregister*.

    A <a>job</a> has a <dfn id="dfn-job-scope-url">scope url</dfn> (a [=/URL=]).

    A <a>job</a> has a <dfn id="dfn-job-script-url">script url</dfn> (a [=/URL=]).

    A <a>job</a> has a <dfn id="dfn-job-worker-type">worker type</dfn> ("<code>classic</code>" or "<code>module</code>").

    A <a>job</a> has an <dfn id="dfn-job-update-via-cache-mode">update via cache mode</dfn>, which is "`imports`", "`all`", or "`none`".

    A <a>job</a> has a <dfn id="dfn-job-client">client</dfn> (a [=/service worker client=]). It is initially null.

    A <a>job</a> has a <dfn>referrer</dfn> (a [=/URL=] or null).

    A <a>job</a> has a <dfn id="dfn-job-promise">job promise</dfn> (a <a>promise</a>). It is initially null.

    A [=job=] has a <dfn id="dfn-containing-job-queue">containing job queue</dfn> (a [=job queue=] or null). It is initially null.

    A <a>job</a> has a <dfn id="dfn-job-list-of-equivalent-jobs">list of equivalent jobs</dfn> (a list of <a>jobs</a>). It is initially the empty list.

    A [=job=] has a <dfn id="dfn-job-force-bypass-cache-flag">force bypass cache flag</dfn>. It is initially unset.
  </div>


  Two <a>jobs</a> are <dfn id="dfn-job-equivalent">equivalent</dfn> when their <a>job type</a> is the same and:

    * For *register* and *update* <a>jobs</a>, their [=job/scope url=], [=job/script url=], [=job/worker type=], and [=job/update via cache mode=] are the same.
    * For *unregister* <a>jobs</a>, their [=job/scope url=] is the same.

  A <dfn id="dfn-job-queue">job queue</dfn> is a thread safe [=queue=] used to synchronize the set of concurrent [=jobs=]. The [=job queue=] contains [=jobs=] as its [=queue/items=]. A [=job queue=] is initially empty.

  A <dfn id="dfn-scope-to-job-queue-map">scope to job queue map</dfn> is an <a>ordered map</a> where the keys are [=service worker registration/scope urls=], [=URL serializer|serialized=], and the values are [=job queues=].

  A <dfn id="dfn-bad-import-script-response">bad import script response</dfn> is a [=/response=] for which any of the following conditions are met:

    * |response|'s [=response/type=] is "`error`"
    * |response|'s [=response/status=] is not an [=ok status=]
    * The result of [=Extract a MIME type|extracting a MIME type=] from |response|'s [=response/header list=] is not a [=JavaScript MIME type=]

        Note: Keep this definition in sync with [=fetch a classic worker-imported script=].

  <section algorithm>
    <h3 id="create-job-algorithm"><dfn>Create Job</dfn></h3>

      : Input
      :: |jobType|, a <a>job type</a>
      :: |scopeURL|, a [=/URL=]
      :: |scriptURL|, a [=/URL=]
      :: |promise|, a <a>promise</a>
      :: |client|, a [=/service worker client=]
      : Output
      :: |job|, a <a>job</a>

      1. Let |job| be a new <a>job</a>.
      1. Set |job|'s [=job/job type=] to |jobType|.
      1. Set |job|'s [=job/scope url=] to |scopeURL|.
      1. Set |job|'s [=job/script url=] to |scriptURL|.
      1. Set |job|'s [=job/job promise=] to |promise|.
      1. Set |job|'s [=job/client=] to |client|.
      1. If |client| is not null, set |job|'s [=job/referrer=] to |client|'s <a>creation URL</a>.
      1. Return |job|.
  </section>

  <section algorithm>
    <h3 id="schedule-job-algorithm"><dfn>Schedule Job</dfn></h3>

      : Input
      :: |job|, a <a>job</a>
      : Output
      :: none

      1. Let |jobQueue| be null.
      1. Let |jobScope| be |job|'s [=job/scope url=], [=URL serializer|serialized=].
      1. If [=scope to job queue map=][|jobScope|] does not [=map/exist=], [=map/set=] [=scope to job queue map=][|jobScope|] to a new [=job queue=].
      1. Set |jobQueue| to [=scope to job queue map=][|jobScope|].
      1. If |jobQueue| is empty, then:
          1. Set |job|'s [=containing job queue=] to |jobQueue|, and [=queue/enqueue=] |job| to |jobQueue|.
          1. Invoke [=Run Job=] with |jobQueue|.
      1. Else:
          1. Let |lastJob| be the element at the back of |jobQueue|.
          1. If |job| is [=equivalent=] to |lastJob| and |lastJob|'s [=job/job promise=] has not settled, append |job| to |lastJob|'s [=list of equivalent jobs=].
          1. Else, set |job|'s [=containing job queue=] to |jobQueue|, and [=queue/enqueue=] |job| to |jobQueue|.
  </section>

  <section algorithm>
    <h3 id="run-job-algorithm"><dfn>Run Job</dfn></h3>

      : Input
      :: jobQueue, a [=job queue=]
      : Output
      :: none

      1. Assert: |jobQueue| [=queue/is not empty=].
      1. [=Queue a task=] to run these steps:
          1. Let |job| be the first [=queue/item=] in |jobQueue|.
          1. If |job|'s [=job type=] is *register*, run [=Register=] with |job| [=in parallel=].
          1. Else if |job|'s [=job type=] is *update*, run [=Update=] with |job| [=in parallel=].

              Note: For a register job and an update job, the user agent delays queuing a task for running the job until after a {{Document/DOMContentLoaded}} event has been dispatched to the document that initiated the job.

          1. Else if |job|'s [=job type=] is *unregister*, run [=Unregister=] with |job| [=in parallel=].
  </section>

  <section algorithm>
    <h3 id="finish-job-algorithm"><dfn>Finish Job</dfn></h3>

      : Input
      :: |job|, a [=job=]
      : Output
      :: none

      1. Let |jobQueue| be |job|'s [=containing job queue=].
      1. Assert: the first [=queue/item=] in |jobQueue| is |job|.
      1. [=Dequeue=] from |jobQueue|.
      1. If |jobQueue| [=queue/is not empty=], invoke [=Run Job=] with |jobQueue|.
  </section>

  <section algorithm>
    <h3 id="resolve-job-promise-algorithm"><dfn>Resolve Job Promise</dfn></h3>

      : Input
      :: |job|, a [=job=]
      :: |value|, any
      : Output
      :: none

      1. If |job|'s [=job/client=] is not null, [=queue a task=], on |job|'s [=job/client=]'s [=responsible event loop=] using the [=DOM manipulation task source=], to run the following substeps:
          1. Let |convertedValue| be null.
          1. If |job|'s [=job/job type=] is either *register* or *update*, set |convertedValue| to the result of [=getting the service worker registration object=] that represents |value| in |job|'s [=job/client=].
          1. Else, set |convertedValue| to |value|, in |job|'s [=job/client=]'s [=environment settings object/Realm=].
          1. Resolve |job|'s [=job/job promise=] with |convertedValue|.
      1. For each |equivalentJob| in |job|'s <a>list of equivalent jobs</a>:
          1. If |equivalentJob|'s [=job/client=] is null, continue to the next iteration of the loop.
          1. [=Queue a task=], on |equivalentJob|'s [=job/client=]'s [=responsible event loop=] using the [=DOM manipulation task source=], to run the following substeps:
              1. Let |convertedValue| be null.
              1. If |equivalentJob|'s [=job/job type=] is either *register* or *update*, set |convertedValue| to the result of [=getting the service worker registration object=] that represents |value| in |equivalentJob|'s [=job/client=].
              1. Else, set |convertedValue| to |value|, in |equivalentJob|'s [=job/client=]'s [=environment settings object/Realm=].
              1. Resolve |equivalentJob|'s [=job/job promise=] with |convertedValue|.
  </section>

  <section algorithm>
    <h3 id="reject-job-promise-algorithm"><dfn>Reject Job Promise</dfn></h3>

      : Input
      :: |job|, a [=job=]
      :: |errorData|, the information necessary to [=exception/create|create an exception=]
      : Output
      :: none

      1. If |job|'s [=job/client=] is not null, [=queue a task=], on |job|'s [=job/client=]'s [=responsible event loop=] using the [=DOM manipulation task source=], to reject |job|'s [=job/job promise=] with a [=exception/create|new=] [=exception=] with |errorData| and a user agent-defined [=exception/message=], in |job|'s [=job/client=]'s [=environment settings object/Realm=].
      1. For each |equivalentJob| in |job|'s [=list of equivalent jobs=]:
          1. If |equivalentJob|'s [=job/client=] is null, [=iteration/continue=].
          1. [=Queue a task=], on |equivalentJob|'s [=job/client=]'s [=responsible event loop=] using the [=DOM manipulation task source=], to reject |equivalentJob|'s [=job/job promise=] with a [=exception/create|new=] [=exception=] with |errorData| and a user agent-defined [=exception/message=], in |equivalentJob|'s [=job/client=]'s [=environment settings object/Realm=].
  </section>

  <section algorithm>
    <h3 id="start-register-algorithm"><dfn>Start Register</dfn></h3>

      : Input
      :: |scopeURL|, a [=/URL=] or failure or null
      :: |scriptURL|, a [=/URL=] or failure
      :: |promise|, a <a>promise</a>
      :: |client|, a [=/service worker client=]
      :: |referrer|, a [=/URL=]
      :: |workerType|, a <a>worker type</a>
      :: |updateViaCache|, an [=service worker registration/update via cache mode=]
      : Output
      :: none

      1. If |scriptURL| is failure, reject |promise| with a <code>TypeError</code> and abort these steps.
      1. Set |scriptURL|'s [=url/fragment=] to null.

          Note: The user agent does not store the [=url/fragment=] of the script's url. This means that the [=url/fragment=] does not have an effect on identifying [=/service workers=].

      1. If |scriptURL|'s [=url/scheme=] is not one of "<code>http</code>" and "<code>https</code>", reject |promise| with a <code>TypeError</code> and abort these steps.
      1. If any of the strings in |scriptURL|'s [=url/path=] contains either <a>ASCII case-insensitive</a> "<code>%2f</code>" or <a>ASCII case-insensitive</a> "<code>%5c</code>", reject |promise| with a <code>TypeError</code> and abort these steps.
      1. If |scopeURL| is null, set |scopeURL| to the result of <a lt="URL parser">parsing</a> the string "<code>./</code>" with |scriptURL|.

          Note: The scope url for the registration is set to the location of the service worker script by default.

      1. If |scopeURL| is failure, reject |promise| with a <code>TypeError</code> and abort these steps.
      1. Set |scopeURL|'s [=url/fragment=] to null.

          Note: The user agent does not store the [=url/fragment=] of the scope url. This means that the [=url/fragment=] does not have an effect on identifying [=/service worker registrations=].

      1. If |scopeURL|'s [=url/scheme=] is not one of "<code>http</code>" and "<code>https</code>", reject |promise| with a <code>TypeError</code> and abort these steps.
      1. If any of the strings in |scopeURL|'s [=url/path=] contains either <a>ASCII case-insensitive</a> "<code>%2f</code>" or <a>ASCII case-insensitive</a> "<code>%5c</code>", reject |promise| with a <code>TypeError</code> and abort these steps.
      1. Let |job| be the result of running [=Create Job=] with *register*, |scopeURL|, |scriptURL|, |promise|, and |client|.
      1. Set |job|'s [=job/worker type=] to |workerType|.
      1. Set |job|'s [=job/update via cache mode=] to |updateViaCache|.
      1. Set |job|'s [=job/referrer=] to |referrer|.
      1. Invoke [=Schedule Job=] with |job|.
  </section>

  <section algorithm>
    <h3 id="register-algorithm"><dfn>Register</dfn></h3>

      : Input
      :: |job|, a <a>job</a>
      : Output
      :: none

      1. If the result of running <a>potentially trustworthy origin</a> with the [=environment settings object/origin=] of |job|'s [=job/script url=] as the argument is <code>Not Trusted</code>, then:
          1. Invoke [=Reject Job Promise=] with |job| and "{{SecurityError}}" {{DOMException}}.
          1. Invoke <a>Finish Job</a> with |job| and abort these steps.
      1. If |job|'s [=job/script url=]'s [=url/origin=] and |job|'s [=job/referrer=]'s [=url/origin=] are not [=same origin=], then:
          1. Invoke [=Reject Job Promise=] with |job| and "{{SecurityError}}" {{DOMException}}.
          1. Invoke <a>Finish Job</a> with |job| and abort these steps.
      1. If |job|'s [=job/scope url=]'s [=url/origin=] and |job|'s [=job/referrer=]'s [=url/origin=] are not [=same origin=], then:
          1. Invoke [=Reject Job Promise=] with |job| and "{{SecurityError}}" {{DOMException}}.
          1. Invoke <a>Finish Job</a> with |job| and abort these steps.
      1. Let |registration| be the result of running the <a>Get Registration</a> algorithm passing |job|'s [=job/scope url=] as the argument.
      1. If |registration| is not null, then:
          1. Let |newestWorker| be the result of running the <a>Get Newest Worker</a> algorithm passing |registration| as the argument.
          1. If |newestWorker| is not null, |job|'s [=job/script url=] [=url/equals=] |newestWorker|'s [=service worker/script url=], |job|'s [=job/worker type=] equals |newestWorker|'s [=service worker/type=], and |job|'s [=job/update via cache mode=]'s value equals |registration|'s [=service worker registration/update via cache mode=], then:
              1. Invoke [=Resolve Job Promise=] with |job| and |registration|.
              1. Invoke <a>Finish Job</a> with |job| and abort these steps.
      1. Else:
          1. Invoke <a>Set Registration</a> algorithm with |job|'s [=job/scope url=] and |job|'s [=job/update via cache mode=].
      1. Invoke <a>Update</a> algorithm passing |job| as the argument.
  </section>

  <section algorithm>
    <h3 id="update-algorithm"><dfn>Update</dfn></h3>

      : Input
      :: |job|, a <a>job</a>
      : Output
      :: none

      1. Let |registration| be the result of running the <a>Get Registration</a> algorithm passing |job|'s [=job/scope url=] as the argument.
      1. If |registration| is null, then:
          1. Invoke [=Reject Job Promise=] with |job| and `TypeError`.
          1. Invoke <a>Finish Job</a> with |job| and abort these steps.
      1. Let |newestWorker| be the result of running <a>Get Newest Worker</a> algorithm passing |registration| as the argument.
      1. If |job|'s <a>job type</a> is *update*, and |newestWorker| is not null and its [=service worker/script url=] does not [=url/equal=] |job|'s [=job/script url=], then:
          1. Invoke [=Reject Job Promise=] with |job| and `TypeError`.
          1. Invoke <a>Finish Job</a> with |job| and abort these steps.
      1. Let |referrerPolicy| be the empty string.
      1. Let |hasUpdatedResources| be false.
      1. Let |updatedResourceMap| be an [=ordered map=] where the [=map/keys=] are [=/URLs=] and the [=map/values=] are [=/responses=].
      1. Switching on |job|'s [=worker type=], run these substeps with the following options:
          <!-- TODO: reorganize algorithm so that the worker environment is created before fetching happens -->
          : "<code>classic</code>"
          :: <a>Fetch a classic worker script</a> given |job|’s <a lt="URL serializer">serialized</a> [=job/script url=], |job|’s [=job/client=], "<code>serviceworker</code>", and the to-be-created <a>environment settings object</a> for this service worker.
          : "<code>module</code>"
          :: <a>Fetch a module worker script graph</a> given |job|’s <a lt="URL serializer">serialized</a> [=job/script url=], |job|’s [=job/client=], "<code>serviceworker</code>", "<code>omit</code>", and the to-be-created <a>environment settings object</a> for this service worker.

          Issue: Using the to-be-created [=environment settings object=] rather than a concrete [=environment settings object=]. This is used due to the unique processing model of service workers compared to the processing model of other [=web workers=]. The script fetching algorithms of HTML standard originally designed for other [=web workers=] require an [=environment settings object=] of the execution environment, but service workers fetch a script separately in the [=Update=] algorithm before the script later runs multiple times through the [=Run Service Worker=] algorithm.

          Issue: The [=fetch a classic worker script=] algorithm and the [=fetch a module worker script graph=] algorithm in HTML take |job|’s [=job/client=] as an argument. |job|’s [=job/client=] is null when passed from the [=Soft Update=] algorithm.

          To [=fetching scripts/perform the fetch=] given |request|, run the following steps:

          1. Append \`<code>Service-Worker</code>\`/\`<code>script</code>\` to |request|'s [=request/header list=].

            Note: See the definition of the Service-Worker header in Appendix B: Extended HTTP headers.

          1. Set |request|'s [=request/cache mode=] to "<code>no-cache</code>" if any of the following are true:
              * |registration|'s [=service worker registration/update via cache mode=] is not "`all`".
              * |job|'s [=force bypass cache flag=] is set.
              * |newestWorker| is not null and |registration| is [=stale=].

              Note: Even if the cache mode is not set to "<code>no-cache</code>", the user agent obeys Cache-Control header's max-age value in the network layer to determine if it should bypass the browser cache.

          1. Set |request|'s [=service-workers mode=] to "`none`".
          1. If the [=fetching scripts/is top-level=] flag is unset, then return the result of [=/fetching=] |request|.
          1. Set |request|'s [=request/redirect mode=] to "<code>error</code>".
          1. [=/Fetch=] |request|, and asynchronously wait to run the remaining steps as part of fetch's <a>process response</a> for the [=/response=] |response|.
          1. [=Extract a MIME type=] from the |response|'s [=response/header list=]. If this MIME type (ignoring parameters) is not a [=JavaScript MIME type=], then:
              1. Invoke [=Reject Job Promise=] with |job| and "{{SecurityError}}" {{DOMException}}.
              1. Asynchronously complete these steps with a [=network error=].
          1. Let |serviceWorkerAllowed| be the result of [=extracting header list values=] given \`<code>Service-Worker-Allowed</code>\` and |response|'s [=response/header list=].

              Note: See the definition of the [=Service-Worker-Allowed=] header in Appendix B: Extended HTTP headers.

          1. Set |policyContainer| to the result of <a>creating a policy container from a fetch response</a> given |response|.
          1. If |serviceWorkerAllowed| is failure, then:
              1. Asynchronously complete these steps with a <a>network error</a>.
          1. Let |scopeURL| be |registration|'s [=service worker registration/scope url=].
          1. Let |maxScopeString| be null.
          1. If |serviceWorkerAllowed| is null, then:
              1. Let |resolvedScope| be the result of [=URL parser|parsing=] "`./`" using |job|'s [=job/script url=] as the [=base URL=].
              1. Set |maxScopeString| to "`/`", followed by the strings in |resolvedScope|'s [=url/path=] (including empty strings), separated from each other by "`/`".

                  Note: The final item in |resolvedScope|'s [=url/path=] will always be an empty string, so |maxScopeString| will have a trailing "`/`".

          1. Else:
              1. Let |maxScope| be the result of [=URL parser|parsing=] |serviceWorkerAllowed| using |job|'s [=job/script url=] as the [=base URL=].
              1. If |maxScope|'s [=url/origin=] is |job|'s [=job/script url=]'s [=url/origin=], then:
                  1. Set |maxScopeString| to "`/`", followed by the strings in |maxScope|'s [=url/path=] (including empty strings), separated from each other by "`/`".
          1. Let |scopeString| be "`/`", followed by the strings in |scopeURL|'s [=url/path=] (including empty strings), separated from each other by "`/`".
          1. If |maxScopeString| is null or |scopeString| does not start with |maxScopeString|, then:
              1. Invoke [=Reject Job Promise=] with |job| and "{{SecurityError}}" {{DOMException}}.
              1. Asynchronously complete these steps with a <a>network error</a>.
          1. Let |url| be |request|'s [=request/url=].
          1. Set |updatedResourceMap|[|url|] to |response|.
          1. If |response|'s [=response/cache state=] is not "`local`", set |registration|'s [=last update check time=] to the current time.
          1. Set |hasUpdatedResources| to true if any of the following are true:
            * |newestWorker| is null.
            * |newestWorker|'s [=service worker/script url=] is not |url| or |newestWorker|'s [=service worker/type=] is not |job|'s [=worker type=].
            * |newestWorker|'s [=script resource map=][|url|]'s [=response/body=] is not byte-for-byte identical with |response|'s [=response/body=].
          1. If |hasUpdatedResources| is false and |newestWorker|'s [=classic scripts imported flag=] is set, then:

              Note: The following checks to see if an imported script has been updated, since the main script has not changed.

              1. [=map/For each=] |importUrl| → |storedResponse| of |newestWorker|'s [=script resource map=]:
                  1. If |importUrl| is |url|, then continue.
                  1. Let |importRequest| be a new [=/request=] whose [=request/url=] is |importUrl|, [=request/client=] is |job|'s [=job/client=], [=request/destination=] is "`script`", [=request/parser metadata=] is "`not parser-inserted`", [=request/synchronous flag=] is set, and whose [=request/use-URL-credentials flag=] is set.
                  1. Set |importRequest|'s [=request/cache mode=] to "`no-cache`" if any of the following are true:
                      * |registration|'s [=service worker registration/update via cache mode=] is "`none`".
                      * |job|'s [=force bypass cache flag=] is set.
                      * |registration| is [=stale=].
                  1. Let |fetchedResponse| be the result of [=fetch|fetching=] |importRequest|.
                  1. Set |updatedResourceMap|[|importRequest|'s [=request/url=]] to |fetchedResponse|.
                  1. Set |fetchedResponse| to |fetchedResponse|'s [=unsafe response=].
                  1. If |fetchedResponse|'s [=response/cache state=] is not "`local`", set |registration|’s [=last update check time=] to the current time.
                  1. If |fetchedResponse| is a [=bad import script response=], continue.

                    Note: Bad responses for <a>importScripts()</a> are ignored for the purpose of the byte-to-byte check. Only good responses for the incumbent worker and good responses for the potential update worker are considered. See <a href="https://github.com/w3c/ServiceWorker/issues/1374">issue #1374</a> for some rationale.

                  1. If |fetchedResponse|'s [=response/body=] is not byte-for-byte identical with |storedResponse|'s [=unsafe response=]'s [=response/body=], set |hasUpdatedResources| to true.

                      Note: The control does not break the loop in this step to continue with all the imported scripts to populate the cache.
          1. Asynchronously complete these steps with |response|.

          When the algorithm asynchronously completes, continue the rest of these steps, with |script| being the asynchronous completion value.

      1. If |script| is null or [=Is Async Module=] with |script|'s [=script/record=], |script|'s [=script/base URL=], and « » is true, then:
          1. Invoke [=Reject Job Promise=] with |job| and `TypeError`.

              Note: This will do nothing if [=Reject Job Promise=] was previously invoked with "{{SecurityError}}" {{DOMException}}.

          1. If |newestWorker| is null, then [=map/remove=] [=scope to registration map=][|scopeURL|, [=URL serializer|serialized=]].
          1. Invoke [=Finish Job=] with |job| and abort these steps.
      1. If |hasUpdatedResources| is false, then:
          1. Set |registration|'s [=service worker registration/update via cache mode=] to |job|'s [=job/update via cache mode=].
          1. Invoke [=Resolve Job Promise=] with |job| and |registration|.
          1. Invoke [=Finish Job=] with |job| and abort these steps.
      1. Let |worker| be a new [=/service worker=].
      1. Set |worker|'s [=service worker/script url=] to |job|'s [=job/script url=], |worker|'s [=script resource=] to |script|, |worker|'s [=service worker/type=] to |job|'s [=worker type=], and |worker|'s [=script resource map=] to |updatedResourceMap|.
      1. Append |url| to |worker|'s [=set of used scripts=].
      1. Set |worker|'s <a>script resource</a>'s [=script resource/policy container=] to |policyContainer|.
      1. Let |forceBypassCache| be true if |job|'s [=job/force bypass cache flag=] is set, and false otherwise.
      1. Let |runResult| be the result of running the [=Run Service Worker=] algorithm with |worker| and |forceBypassCache|.
      1. If |runResult| is *failure* or an [=abrupt completion=], then:
          1. Invoke [=Reject Job Promise=] with |job| and `TypeError`.
          1. If |newestWorker| is null, then [=map/remove=] [=scope to registration map=][|registration|'s [=service worker registration/scope url=], [[=URL serializer|serialized=]].
          1. Invoke [=Finish Job=] with |job|.
      1. Else, invoke [=Install=] algorithm with |job|, |worker|, and |registration| as its arguments.
  </section>

  <section algorithm>
    <h3 id="soft-update-algorithm"><dfn>Soft Update</dfn></h3>

    The user agent *may* call this as often as it likes to check for updates.

      : Input
      :: |registration|, a [=/service worker registration=]
      :: |forceBypassCache|, an optional boolean, false by default

        Note: Implementers may use |forceBypassCache| to aid debugging (e.g. invocations from developer tools), and other specifications that extend service workers may also use the flag on their own needs.

      : Output
      :: None

      1. Let |newestWorker| be the result of running <a>Get Newest Worker</a> algorithm passing |registration| as its argument.
      1. If |newestWorker| is null, abort these steps.
      1. Let |job| be the result of running <a>Create Job</a> with *update*, |registration|'s [=service worker registration/scope url=], |newestWorker|'s [=service worker/script url=], null, and null.
      1. Set |job|'s <a>worker type</a> to |newestWorker|'s [=service worker/type=].
      1. Set |job|'s [=force bypass cache flag=] if |forceBypassCache| is true.
      1. Invoke <a>Schedule Job</a> with |job|.
  </section>

  <section algorithm>
    <h3 id="installation-algorithm"><dfn>Install</dfn></h3>

      : Input
      :: |job|, a <a>job</a>
      :: |worker|, a [=/service worker=]
      :: |registration|, a [=/service worker registration=]
      : Output
      :: none

      1. Let |installFailed| be false.
      1. Let |newestWorker| be the result of running <a>Get Newest Worker</a> algorithm passing |registration| as its argument.
      1. Set |registration|'s [=service worker registration/update via cache mode=] to |job|'s [=job/update via cache mode=].
      1. Run the <a>Update Registration State</a> algorithm passing |registration|, "<code>installing</code>" and |worker| as the arguments.
      1. Run the <a>Update Worker State</a> algorithm passing |registration|'s <a>installing worker</a> and "`installing`" as the arguments.
      1. Assert: |job|'s [=job/job promise=] is not null.
      1. Invoke [=Resolve Job Promise=] with |job| and |registration|.
      1. Let |settingsObjects| be all [=environment settings objects=] whose [=environment settings object/origin=] is |registration|'s [=service worker registration/scope url=]'s [=url/origin=].
      1. For each |settingsObject| of |settingsObjects|, [=queue a task=] on |settingsObject|'s [=responsible event loop=] in the [=DOM manipulation task source=] to run the following steps:
          1. Let |registrationObjects| be every {{ServiceWorkerRegistration}} object in |settingsObject|'s [=environment settings object/realm=], whose [=ServiceWorkerRegistration/service worker registration=] is |registration|.
          1. For each |registrationObject| of |registrationObjects|, [=fire an event=] on |registrationObject| named `updatefound`.
      1. Let |installingWorker| be |registration|'s <a>installing worker</a>.
      1. If the result of running the [=Should Skip Event=] algorithm with |installingWorker| and "install" is false, then:
          1. Let |forceBypassCache| be true if |job|'s [=job/force bypass cache flag=] is set, and false otherwise.
          1. If the result of running the [=Run Service Worker=] algorithm with |installingWorker| and |forceBypassCache| is *failure*, then:
              1. Set |installFailed| to true.
          1. Else:
              1. [=Queue a task=] |task| on |installingWorker|'s [=event loop=] using the [=DOM manipulation task source=] to run the following steps:
                  1. Let |e| be the result of <a>creating an event</a> with {{ExtendableEvent}}.
                  1. Initialize |e|’s {{Event/type}} attribute to {{install!!event}}.
                  1. <a>Dispatch</a> |e| at |installingWorker|'s [=service worker/global object=].
                  1. *WaitForAsynchronousExtensions*: Run the following substeps <a>in parallel</a>:
                      1. <span id="install-settle-step">Wait until |e| is not [=ExtendableEvent/active=].</span>
                      1. If |e|'s [=ExtendableEvent/timed out flag=] is set, set |installFailed| to true.
                      1. Let |p| be the result of [=getting a promise to wait for all=] of |e|'s [=extend lifetime promises=].
                      1. [=Upon rejection=] of |p|, set |installFailed| to true.

                  If |task| is discarded, set |installFailed| to true.

              1. Wait for |task| to have executed or been discarded.
              1. Wait for the step labeled *WaitForAsynchronousExtensions* to complete.
      1. If |installFailed| is true, then:
          1. Run the <a>Update Worker State</a> algorithm passing |registration|'s [=installing worker=] and "`redundant`" as the arguments.
          1. Run the <a>Update Registration State</a> algorithm passing |registration|, "<code>installing</code>" and null as the arguments.
          1. If |newestWorker| is null, then [=map/remove=] [=scope to registration map=][|registration|'s [=service worker registration/scope url=], [[=URL serializer|serialized=]].
          1. Invoke <a>Finish Job</a> with |job| and abort these steps.
      1. Let |map| be |registration|'s [=installing worker=]'s [=script resource map=].
      1. Let |usedSet| be |registration|'s [=installing worker=]'s [=set of used scripts=].
      1. [=map/For each=] |url| of |map|:
          1. If |usedSet| does not [=list/contain=] |url|, then [=map/remove=] |map|[|url|].
      1. If |registration|'s <a>waiting worker</a> is not null, then:
          1. [=Terminate Service Worker|Terminate=] |registration|'s [=waiting worker=].
          1. Run the [=Update Worker State=] algorithm passing |registration|'s [=waiting worker=] and "`redundant`" as the arguments.
      1. Run the <a>Update Registration State</a> algorithm passing |registration|, "<code>waiting</code>" and |registration|'s <a>installing worker</a> as the arguments.
      1. Run the <a>Update Registration State</a> algorithm passing |registration|, "<code>installing</code>" and null as the arguments.
      1. Run the <a>Update Worker State</a> algorithm passing |registration|'s <a>waiting worker</a> and "`installed`" as the arguments.
      1. Invoke <a>Finish Job</a> with |job|.
      1. Wait for all the <a>tasks</a> <a lt="queue a task">queued</a> by <a>Update Worker State</a> invoked in this algorithm to have executed.
      1. Invoke [=Try Activate=] with |registration|.

          Note: If [=Try Activate=] does not trigger [=Activate=] here, [=Activate=] is tried again when the last client controlled by the existing [=active worker=] is [=Handle Service Worker Client Unload|unloaded=], {{ServiceWorkerGlobalScope/skipWaiting()}} is asynchronously called, or the [=extend lifetime promises=] for the existing [=active worker=] settle.
  </section>

  <section algorithm>
    <h3 id="activation-algorithm"><dfn>Activate</dfn></h3>

      : Input
      :: |registration|, a [=/service worker registration=]
      : Output
      :: None

      1. If |registration|'s <a>waiting worker</a> is null, abort these steps.
      1. If |registration|'s [=active worker=] is not null, then:
          1. [=Terminate Service Worker|Terminate=] |registration|'s [=active worker=].
          1. Run the [=Update Worker State=] algorithm passing |registration|'s [=active worker=] and "`redundant`" as the arguments.
      1. Run the <a>Update Registration State</a> algorithm passing |registration|, "<code>active</code>" and |registration|'s <a>waiting worker</a> as the arguments.
      1. Run the <a>Update Registration State</a> algorithm passing |registration|, "<code>waiting</code>" and null as the arguments.
      1. Run the <a>Update Worker State</a> algorithm passing |registration|'s <a>active worker</a> and "`activating`" as the arguments.

          Note: Once an active worker is activating, neither a runtime script error nor a force termination of the active worker prevents the active worker from getting activated.

          Note: Make sure to design activation handlers to do non-essential work (like cleanup). This is because activation handlers may not all run to completion, especially in the case of browser termination during activation. A Service Worker should be designed to function properly, even if the activation handlers do not all complete successfully.

      1. Let |matchedClients| be a [=list=] of [=/service worker clients=] whose <a>creation URL</a> <a lt="Match Service Worker Registration">matches</a> |registration|'s [=service worker registration/scope url=].
      1. [=list/For each=] |client| of |matchedClients|, [=queue a task=] on |client|'s [=responsible event loop=], using the [=DOM manipulation task source=], to run the following substeps:
          1. Let |readyPromise| be |client|'s [=environment settings object/global object=]'s {{ServiceWorkerContainer}} object's [=ServiceWorkerContainer/ready promise=].
          1. If |readyPromise| is null, then [=continue=].
          1. <span id="activate-resolve-ready-step">If |readyPromise| is pending, resolve |readyPromise| with the the result of [=getting the service worker registration object=] that represents |registration| in |readyPromise|'s [=relevant settings object=]</span>.
      1. [=list/For each=] |client| of |matchedClients|:
          1. If |client| is a <a>window client</a>, unassociate |client|'s <a>responsible document</a> from its <a>application cache</a>, if it has one.
          1. Else if |client| is a <a>shared worker client</a>, unassociate |client|'s [=environment settings object/global object=] from its <a>application cache</a>, if it has one.

          Note: Resources will now use the service worker registration instead of the existing application cache.

      1. For each [=/service worker client=] |client| who is <a>using</a> |registration|:
          1. Set |client|'s <a>active worker</a> to |registration|'s <a>active worker</a>.
          1. Invoke <a>Notify Controller Change</a> algorithm with |client| as the argument.
      1. Let |activeWorker| be |registration|'s <a>active worker</a>.
      1. If the result of running the [=Should Skip Event=] algorithm with |activeWorker| and "activate" is false, then:
          1. If the result of running the [=Run Service Worker=] algorithm with |activeWorker| is not *failure*, then:
              1. [=Queue a task=] |task| on |activeWorker|'s [=event loop=] using the [=DOM manipulation task source=] to run the following steps:
                  1. Let |e| be the result of <a>creating an event</a> with {{ExtendableEvent}}.
                  1. Initialize |e|’s {{Event/type}} attribute to {{activate!!event}}.
                  1. <a>Dispatch</a> |e| at |activeWorker|'s [=service worker/global object=].
                  1. <span id="activate-settle-step">*WaitForAsynchronousExtensions*: Wait, [=in parallel=], until |e| is not [=ExtendableEvent/active=].</span>
              1. Wait for |task| to have executed or been discarded.
              1. Wait for the step labeled *WaitForAsynchronousExtensions* to complete.
      1. Run the <a>Update Worker State</a> algorithm passing |registration|'s <a>active worker</a> and "`activated`" as the arguments.
  </section>

  <section algorithm>
    <h3 id="try-activate-algorithm"><dfn>Try Activate</dfn></h3>

      : Input
      :: |registration|, a [=/service worker registration=]
      : Output
      :: None

      1. If |registration|'s [=waiting worker=] is null, return.
      1. If |registration|'s [=active worker=] is not null and |registration|'s [=active worker=]'s [=state=] is "`activating`", return.

          Note: If the existing active worker is still in activating state, the activation of the waiting worker is delayed.

      1. Invoke [=Activate=] with |registration| if either of the following is true:
        * |registration|'s [=active worker=] is null.
        * The result of running [=Service Worker Has No Pending Events=] with |registration|’s [=active worker=] is true, and no [=/service worker client=] is [=using=] |registration| or |registration|’s [=waiting worker=]'s [=skip waiting flag=] is set.
  </section>

  <section algorithm>
    <h3 id="run-service-worker-algorithm"><dfn>Run Service Worker</dfn></h3>

      : Input
      :: |serviceWorker|, a [=/service worker=]
      :: |forceBypassCache|, an optional boolean, false by default
      : Output
      :: a [=Completion=] or *failure*

      Note: This algorithm blocks until the service worker is [=running=] or fails to start.

      1. If |serviceWorker| is [=running=], then return |serviceWorker|'s [=start status=].
      1. If |serviceWorker|'s [=state=] is "`redundant`", then return *failure*.
      1. Assert: |serviceWorker|'s [=start status=] is null.
      1. Let |script| be |serviceWorker|'s [=service worker/script resource=].
      1. Assert: |script| is not null.
      1. Let |startFailed| be false.
      1. Let |agent| be the result of [=obtain a service worker agent|obtaining a service worker agent=], and run the following steps in that context:
          1. Let |realmExecutionContext| be the result of [=create a new JavaScript realm|creating a new JavaScript realm=] given |agent| and the following customizations:
              * For the global object, create a new {{ServiceWorkerGlobalScope}} object. Let |workerGlobalScope| be the created object.
          1. Set |serviceWorker|'s [=service worker/global object=] to |workerGlobalScope|.
          1. Let |settingsObject| be a new <a>environment settings object</a> whose algorithms are defined as follows:

              : The [=environment settings object/realm execution context=]
              :: Return |realmExecutionContext|.
              : The [=environment settings object/module map=]
              :: Return |workerGlobalScope|'s [=WorkerGlobalScope/module map=].
              : The <a>API URL character encoding</a>
              :: Return [=UTF-8=].
              : The <a>API base URL</a>
              :: Return |serviceWorker|'s [=service worker/script url=].
              : The [=environment settings object/origin=]
              :: Return its registering [=/service worker client=]'s [=environment settings object/origin=].
              : The [=environment settings object/policy container=]
              :: Return |workerGlobalScope|'s [=WorkerGlobalScope/policy container=].

          1. Set |settingsObject|'s [=environment/id=] to a new unique opaque string, [=creation URL=] to |serviceWorker|'s [=service worker/script url=], [=environment/top-level creation URL=] to null, [=environment/top-level origin=] to an [=implementation-defined=] value, [=environment/target browsing context=] to null, and [=active service worker=] to null.
          1. Set |workerGlobalScope|'s [=WorkerGlobalScope/url=] to |serviceWorker|'s [=service worker/script url=].
          1. Set |workerGlobalScope|'s [=WorkerGlobalScope/policy container=] to |serviceWorker|'s <a>script resource</a>'s [=script resource/policy container=].
          1. Set |workerGlobalScope|'s [=WorkerGlobalScope/type=] to |serviceWorker|'s [=service worker/type=].
          1. Set |workerGlobalScope|'s [=ServiceWorkerGlobalScope/force bypass cache for import scripts flag=] if |forceBypassCache| is true.
          1. Create a new {{WorkerLocation}} object and associate it with |workerGlobalScope|.
          1. If the <a>run CSP initialization for a global object</a> algorithm returns "<code>Blocked</code>" when executed upon |workerGlobalScope|, set |startFailed| to true and abort these steps.
          1. If |serviceWorker| is an <a>active worker</a>, and there are any <a>tasks</a> queued in |serviceWorker|'s <a>containing service worker registration</a>'s [=service worker registration/task queues=], <a lt="queue a task">queue</a> them to |serviceWorker|'s <a>event loop</a>'s [=/task queues=] in the same order using their original <a>task sources</a>.
          1. Let |evaluationStatus| be null.
          1. If |script| is a [=classic script=], then:
              1. Set |evaluationStatus| to the result of [=run a classic script|running the classic script=] |script|.
              1. If |evaluationStatus|.\[[Value]] is empty, this means the script was not evaluated. Set |startFailed| to true and abort these steps.
          1. Otherwise, if |script| is a [=module script=], then:
              1. Let |evaluationPromise| be the result of [=run a module script|running the module script=] |script|, with report errors set to false.
              1. Assert: |evaluationPromise|.\[[PromiseState]] is not "pending".
              1. If |evaluationPromise|.\[[PromiseState]] is "rejected":
                  1. Set |evaluationStatus| to [$ThrowCompletion$](|evaluationPromise|.\[[PromiseResult]]).
              1. Otherwise:
                  1. Set |evaluationStatus| to [$NormalCompletion$](undefined).
          1. If the script was aborted by the [=Terminate Service Worker=] algorithm, set |startFailed| to true and abort these steps.
          1. Set |serviceWorker|'s [=start status=] to |evaluationStatus|.
          1. If |script|'s <a>has ever been evaluated flag</a> is unset, then:
              1. For each |eventType| of |settingsObject|'s [=environment settings object/global object=]'s associated list of <a>event listeners</a>' event types:
                  1. [=set/Append=] |eventType| to |workerGlobalScope|'s associated [=ServiceWorkerGlobalScope/service worker=]'s <a>set of event types to handle</a>.

                  Note: If the global object's associated list of event listeners does not have any event listener added at this moment, the service worker's set of event types to handle remains an empty set. The user agents are encouraged to show a warning that the event listeners must be added on the very first evaluation of the worker script.

              1. Set |script|'s <a>has ever been evaluated flag</a>.
          1. Run the <a>responsible event loop</a> specified by |settingsObject| until it is destroyed.
          1. Empty |workerGlobalScope|'s <a>list of active timers</a>.
      1. Wait for |serviceWorker| to be [=running=], or for |startFailed| to be true.
      1. If |startFailed| is true, then return *failure*.
      1. Return |serviceWorker|'s [=start status=].
  </section>

  <section algorithm>
    <h3 id="terminate-service-worker-algorithm"><dfn>Terminate Service Worker</dfn></h3>

      : Input
      :: |serviceWorker|, a [=/service worker=]
      : Output
      :: None

      1. Run the following steps [=in parallel=] with |serviceWorker|'s main loop:
          1. Let |serviceWorkerGlobalScope| be |serviceWorker|'s [=service worker/global object=].
          1. Set |serviceWorkerGlobalScope|'s [=WorkerGlobalScope/closing=] flag to true.
          1. [=set/Remove=] all the [=list/items=] from |serviceWorker|'s [=set of extended events=].
          1. If there are any <a>tasks</a>, whose <a>task source</a> is either the <a>handle fetch task source</a> or the <a>handle functional event task source</a>, queued in |serviceWorkerGlobalScope|'s <a>event loop</a>'s [=/task queues=], <a lt="queue a task">queue</a> them to |serviceWorker|'s <a>containing service worker registration</a>'s corresponding [=service worker registration/task queues=] in the same order using their original <a>task sources</a>, and discard all the <a>tasks</a> (including <a>tasks</a> whose <a>task source</a> is neither the <a>handle fetch task source</a> nor the <a>handle functional event task source</a>) from |serviceWorkerGlobalScope|'s <a>event loop</a>'s [=/task queues=] without processing them.

              Note: This effectively means that the fetch events and the other functional events such as push events are backed up by the registration's task queues while the other tasks including message events are discarded.

          1. [=Abort a running script|Abort the script=] currently running in |serviceWorker|.
          1. Set |serviceWorker|'s [=start status=] to null.
  </section>

  <section algorithm>
    <h3 id="on-fetch-request-algorithm"><dfn export>Handle Fetch</dfn></h3>

    The [=Handle Fetch=] algorithm is the entry point for the [=/fetch=] handling handed to the [=/service worker=] context.

      : Input
      :: |request|, a [=/request=]
      :: |useHighResPerformanceTimers|, a boolean
      : Output
      :: |response|, a [=/response=]

      1. Let |handleFetchFailed| be false.
      1. Let |respondWithEntered| be false.
      1. Let |eventCanceled| be false.
      1. Let |response| be null.
      1. Let |registration| be null.
      1. Let |client| be |request|'s [=request/client=].
      1. Let |reservedClient| be |request|'s [=request/reserved client=].
      1. Let |preloadResponse| be a new [=promise=].
      1. Let |workerRealm| be null.
      1. Let |eventHandled| be null.
      1. Let |timingInfo| be a new [=service worker timing info=].
      1. Let |fetchInstance| be the instance of the [=/fetch=] algorithm representing the ongoing fetch.
      1. Assert: |request|'s [=request/destination=] is not "<code>serviceworker</code>".
      1. If |request|'s [=request/destination=] is either "<code>embed</code>" or "<code>object</code>", then:
          1. Return null.
      1. Else if |request| is a <a>non-subresource request</a>, then:

          Note: If the non-subresource request is under the scope of a service worker registration, application cache is completely bypassed regardless of whether the non-subresource request uses the service worker registration.

          1. If |reservedClient| is not null and is an <a>environment settings object</a>, then:
              1. If |reservedClient| is not a <a>secure context</a>, return null.
          1. Else:
              1. If |request|'s [=request/url=] is not a <a>potentially trustworthy URL</a>, return null.
          1. If |request| is a <a>navigation request</a> and the <a lt="navigate">navigation</a> triggering it was initiated with a shift+reload or equivalent, return null.
          1. Set |registration| to the result of running <a>Match Service Worker Registration</a> algorithm passing |request|'s [=request/url=] as the argument.
          1. If |registration| is null or |registration|'s <a>active worker</a> is null, return null.
          1. If |request|'s [=request/destination=] is not {{RequestDestination/"report"}}, set |reservedClient|'s <a>active service worker</a> to |registration|'s <a>active worker</a>.
          1. If |request| is a [=navigation request=], |registration|'s [=navigation preload enabled flag=] is set, |request|'s [=request/method=] is \`<code>GET</code>\`, and |registration|'s [=active worker=]'s <a>set of event types to handle</a> [=set/contains=] <code>fetch</code>, then:

              Note: If the above is true except |registration|'s [=active worker=]'s <a>set of event types to handle</a> **does not** contain <code>fetch</code>, then the user agent may wish to show a console warning, as the developer's intent isn't clear.

              1. Let |preloadRequest| be the result of [=request/cloning=] the request |request|.
              1. Let |preloadRequestHeaders| be |preloadRequest|'s [=request/header list=].
              1. Let |preloadResponseObject| be a new {{Response}} object associated with a new {{Headers}} object whose [=guard=] is "`immutable`".
              1. [=header list/Append=] to |preloadRequestHeaders| a new [=header=] whose [=header/name=] is \`<code>Service-Worker-Navigation-Preload</code>\` and [=header/value=] is |registration|'s [=navigation preload header value=].
              1. Set |preloadRequest|'s [=service-workers mode=] to "`none`".
              1. Run the following substeps [=in parallel=]:
                  1. [=Fetch=] |preloadRequest| and let |preloadFetchInstance| be the instance of the [=/fetch=] algorithm.

                      To [=process response=] for |navigationPreloadResponse|, run these substeps:

                      1. If |navigationPreloadResponse|'s [=response/type=] is "`error`", reject |preloadResponse| with a `TypeError` and terminate these substeps.
                      1. Associate |preloadResponseObject| with |navigationPreloadResponse|.
                      1. Resolve |preloadResponse| with |preloadResponseObject|.
                  1. If |fetchInstance| is [=fetch/terminated=], then [=fetch/terminate=] |preloadFetchInstance| with the aborted flag set.
          1. Else, resolve |preloadResponse| with undefined.

          Note: From this point, the [=/service worker client=] starts to <a>use</a> its <a>active service worker</a>'s <a>containing service worker registration</a>.

      1. Else if |request| is a <a>subresource request</a>, then:
          1. If |client|'s <a>active service worker</a> is non-null, set |registration| to |client|'s <a>active service worker</a>'s <a>containing service worker registration</a>.
          1. Else, return null.
      1. Let |activeWorker| be |registration|'s <a>active worker</a>.
      1. Let |shouldSoftUpdate| be true if any of the following are true, and false otherwise:
          * |request| is a [=non-subresource request=].
          * |request| is a [=subresource request=] and |registration| is [=stale=].
      1. If the result of running the [=Should Skip Event=] algorithm with "fetch" and |activeWorker| is true, then:
          1. If |shouldSoftUpdate| is true, then [=in parallel=] run the [=Soft Update=] algorithm with |registration|.
          1. Return null.
      1. If |useHighResPerformanceTimers| is true, then set |useHighResPerformanceTimers| to |activeWorker|'s [=service worker/global object=]'s [=WorkerGlobalScope/cross-origin isolated capability=].
      1. Let |timingInfo|'s [=service worker timing info/start time=] be the [=coarsened shared current time=] given |useHighResPerformanceTimers|.
      1. If |activeWorker|'s <a>state</a> is "`activating`", wait for |activeWorker|'s <a>state</a> to become "`activated`".
      1. If the result of running the [=Run Service Worker=] algorithm with |activeWorker| is *failure*, then set |handleFetchFailed| to true.
      1. Else:
          1. Set |workerRealm| to the [=relevant realm=] of the |activeWorker|'s [=service worker/global object=].
          1. Set |eventHandled| to [=a new promise=] in |workerRealm|.
          1. [=Queue a task=] |task| to run the following substeps:
              1. Let |e| be the result of <a>creating an event</a> with {{FetchEvent}}.
              1. Let |requestObject| be a new {{Request}} object associated with |request| and a new associated {{Headers}} object whose [=guard=] is "`immutable`".
              1. Initialize |e|’s {{Event/type}} attribute to {{fetch!!event}}.
              1. Initialize |e|’s {{Event/cancelable}} attribute to true.
              1. Initialize |e|’s {{FetchEvent/request}} attribute to |requestObject|.
              1. Initialize |e|’s {{FetchEvent/preloadResponse}} to |preloadResponse|.
              1. Initialize |e|'s {{FetchEvent/clientId}} attribute to |client|'s [=environment/id=].
              1. If |request| is a <a>non-subresource request</a> and |request|'s [=request/destination=] is not {{RequestDestination/"report"}}, initialize |e|'s {{FetchEvent/resultingClientId}} attribute to |reservedClient|'s [=environment/id=], and to the empty string otherwise.
              1. If |request| is a <a>navigation request</a>, initialize |e|'s {{FetchEvent/replacesClientId}} attribute to |request|'s [=request/replaces client id=], and to the empty string otherwise.
              1. Initialize |e|’s {{FetchEvent/handled}} to |eventHandled|.
              1. Let |timingInfo|'s [=service worker timing info/fetch event dispatch time=] to the [=coarsened shared current time=] given |useHighResPerformanceTimers|.
              1. <a>Dispatch</a> |e| at |activeWorker|'s [=service worker/global object=].
              1. Invoke [=Update Service Worker Extended Events Set=] with |activeWorker| and |e|.
              1. If |e|'s [=FetchEvent/respond-with entered flag=] is set, set |respondWithEntered| to true.
              1. If |e|'s [=FetchEvent/wait to respond flag=] is set, then:
                  1. Wait until |e|'s [=FetchEvent/wait to respond flag=] is unset.
                  1. If |e|'s [=FetchEvent/respond-with error flag=] is set, set |handleFetchFailed| to true.
                  1. Else, set |response| to |e|'s [=FetchEvent/potential response=].
              1. If |response| is null, |request|'s [=request/body=] is not null, and |request|'s [=request/body=]'s [=Body/source=] is null, then:
                  1. If |request|'s [=request/body=] is [=Body/unusable=], set |handleFetchFailed| to true.
                  1. Else, [=ReadableStream/cancel=] |request|'s [=request/body=] with undefined.
              1. If |response| is not null, then set |response|'s [=response/service worker timing info=] to |timingInfo|.
              1. If |e|'s <a>canceled flag</a> is set, set |eventCanceled| to true.
              1. If |fetchInstance| is [=fetch/terminated=], then [=queue a task=] to [=AbortSignal/signal abort=] on |requestObject|'s {{Request/signal}}.

             If |task| is discarded, set |handleFetchFailed| to true.

             The |task| *must* use |activeWorker|'s <a>event loop</a> and the <a>handle fetch task source</a>.

      1. Wait for |task| to have executed or for |handleFetchFailed| to be true.
      1. If |shouldSoftUpdate| is true, then [=in parallel=] run the [=Soft Update=] algorithm with |registration|.
      1. If |respondWithEntered| is false, then:
          1. If |eventCanceled| is true, then:
              1. If |eventHandled| is not null, then [=reject=] |eventHandled| with a "{{NetworkError}}" {{DOMException}} in |workerRealm|.
              2. Return a [=network error=].
          1. If |eventHandled| is not null, then [=resolve=] |eventHandled|.
          1. Return null.
      1. If |handleFetchFailed| is true, then:
          1. If |eventHandled| is not null, then [=reject=] |eventHandled| with a "{{NetworkError}}" {{DOMException}} in |workerRealm|.
          2. Return a [=network error=].
      1. If |eventHandled| is not null, then [=resolve=] |eventHandled|.
      1. Return |response|.
  </section>

  <section algorithm>
    <h3 id="should-skip-event-algorithm"><dfn>Should Skip Event</dfn></h3>
      : Input
      :: |eventName|, a string
      :: |serviceWorker|, a [=/service worker=]
      : Output
      :: a boolean

      Note: To avoid unnecessary delays, this specification permits skipping event dispatch when no event listeners for the event have been deterministically added in the service worker's global during the very first script execution.

      1. If |serviceWorker|'s [=set of event types to handle=] does not [=set/contain=] |eventName|, then the user agent *may* return true.
      1. Return false.
  </section>

  <section algorithm>
    <h3 id="fire-functional-event-algorithm"><dfn export lt="Fire Functional Event|Fire a functional event">Fire Functional Event</dfn></h3>

      : Input
      :: |eventName|, a string
      :: |eventConstructor|, an event constructor that extends {{ExtendableEvent}}
      :: |registration|, a [=/service worker registration=]
      :: |initialization|, optional property initialization for |event|, constructed from |eventConstructor|
      :: |postDispatchSteps|, optional steps to run on the [=service worker registration/active worker=]'s event loop, with |dispatchedEvent| set to the instance of |eventConstructor| that was [=dispatched=].
      : Output
      :: None

      1. Assert: |registration|'s [=active worker=] is not null.
      1. Let |activeWorker| be |registration|'s [=active worker=].
      1. If the result of running [=Should Skip Event=] with |eventName| and |activeWorker| is true, then:
          1. If |registration| is [=stale=], then [=in parallel=] run the [=Soft Update=] algorithm with |registration|.
          2. Return.
      1. If |activeWorker|'s [=state=] is "`activating`", wait for |activeWorker|'s [=state=] to become "`activated`".
      1. If the result of running the [=Run Service Worker=] algorithm with |activeWorker| is *failure*, then:
          1. If |registration| is [=stale=], then [=in parallel=] run the [=Soft Update=] algorithm with |registration|.
          2. Return.
      1. [=Queue a task=] |task| to run these substeps:
          1. Let |event| be the result of [=creating an event=] with |eventConstructor| and the [=relevant realm=] of |activeWorker|'s [=service worker/global object=].
          1. If |initialization| is not null, then initialize |event| with |initialization|.
          1. [=Dispatch=] |event| on |activeWorker|'s [=service worker/global object=].
          1. Invoke [=Update Service Worker Extended Events Set=] with |activeWorker| and |event|.
          1. If |postDispatchSteps| is not null, then run |postDispatchSteps| passing |event| as |dispatchedEvent|.

          The |task| *must* use |activeWorker|'s [=event loop=] and the [=handle functional event task source=].

      1. Wait for |task| to have executed or been discarded.
      1. If |registration| is [=stale=], then [=in parallel=] run the [=Soft Update=] algorithm with |registration|.

      <div class="example">
        To fire an "`amazingthing`" event (which is of type `AmazingThingEvent`) on a particular |serviceWorkerRegistration|, and initialize the event object's properties, the prose would be:

        1. [=Fire Functional Event=] "`amazingthing`" using `AmazingThingEvent` on |serviceWorkerRegistration| with the following properties:
            : propertyName
            :: value
            : anotherPropertyName
            :: anotherValue

            Then run the following steps with |dispatchedEvent|:

            1. Do whatever you need to with |dispatchedEvent| on the service worker's event loop.

        Note that the initialization steps and post-dispatch steps are optional. If they aren't needed, the prose would be:

        1. [=Fire Functional Event=] "`whatever`" using {{ExtendableEvent}} on |serviceWorkerRegistration|.
      </div>
  </section>

  <section algorithm>
    <h3 id="on-client-unload-algorithm"><dfn>Handle Service Worker Client Unload</dfn></h3>

    The user agent *must* run these steps when a [=/service worker client=] unloads by <a lt="unload a document">unloading</a> or <a lt="terminate service worker">terminating</a>.

      : Input
      :: |client|, a [=/service worker client=]
      : Output
      :: None

      1. Run the following steps atomically.
      1. Let |registration| be the [=/service worker registration=] <a>used</a> by |client|.
      1. If |registration| is null, abort these steps.
      1. If any other [=/service worker client=] is <a>using</a> |registration|, abort these steps.
      1. If |registration| is [=service worker registration/unregistered=], invoke [=Try Clear Registration=] with |registration|.
      1. Invoke [=Try Activate=] with |registration|.
  </section>

  <section algorithm>
    <h3 id="on-user-agent-shutdown-algorithm"><dfn>Handle User Agent Shutdown</dfn></h3>

      : Input
      :: None
      : Output
      :: None

      1. [=map/For each=] <var ignore>scope</var> → |registration| of <a>scope to registration map</a>:
          1. If |registration|'s <a>installing worker</a> |installingWorker| is not null, then:
              1. If |registration|'s [=waiting worker=] is null and |registration|'s [=active worker=] is null, invoke <a>Clear Registration</a> with |registration| and continue to the next iteration of the loop.
              1. Else, set |installingWorker| to null.
          1. If |registration|'s <a>waiting worker</a> is not null, run the following substep <a>in parallel</a>:
              1. Invoke <a>Activate</a> with |registration|.
  </section>

  <section algorithm>
    <h3 id="update-service-worker-extended-events-set-algorithm"><dfn>Update Service Worker Extended Events Set</dfn></h3>

      : Input
      :: |worker|, a [=/service worker=]
      :: |event|, an [=event=]
      : Output
      :: None

      1. Assert: |event|'s [=dispatch flag=] is unset.
      1. For each |item| of |worker|'s [=set of extended events=]:
          1. If |item| is not [=ExtendableEvent/active=], [=set/remove=] |item| from |worker|'s [=set of extended events=].
      1. If |event| is [=ExtendableEvent/active=], [=set/append=] |event| to |worker|'s [=set of extended events=].
  </section>

  <section algorithm>
    <h3 id="unregister-algorithm"><dfn>Unregister</dfn></h3>

      : Input
      :: |job|, a <a>job</a>
      : Output
      :: none

      1. If the [=environment settings object/origin=] of |job|'s [=job/scope url=] is not |job|'s [=job/client=]'s [=environment settings object/origin=], then:
          1. Invoke [=Reject Job Promise=] with |job| and "{{SecurityError}}" {{DOMException}}.
          1. Invoke <a>Finish Job</a> with |job| and abort these steps.
      1. Let |registration| be the result of running <a>Get Registration</a> algorithm passing |job|'s [=job/scope url=] as the argument.
      1. If |registration| is null, then:
          1. Invoke <a>Resolve Job Promise</a> with |job| and false.
          1. Invoke <a>Finish Job</a> with |job| and abort these steps.
      1. [=map/Remove=] [=scope to registration map=][|job|'s [=job/scope url=]].
      1. Invoke <a>Resolve Job Promise</a> with |job| and true.
      1. Invoke [=Try Clear Registration=] with |registration|.

          Note: If [=Try Clear Registration=] does not trigger [=Clear Registration=] here, [=Clear Registration=] is tried again when the last client [=using=] the registration is [=Handle Service Worker Client Unload|unloaded=] or the [=extend lifetime promises=] for the registration's service workers settle.

      1. Invoke <a>Finish Job</a> with |job|.
  </section>

  <section algorithm>
    <h3 id="set-registration-algorithm"><dfn>Set Registration</dfn></h3>

      : Input
      :: |scope|, a [=/URL=]
      :: |updateViaCache|, an [=service worker registration/update via cache mode=]
      : Output
      :: |registration|, a [=/service worker registration=]

      1. Run the following steps atomically.
      1. Let |scopeString| be [=URL serializer|serialized=] |scope| with the *exclude fragment flag* set.
      1. Let |registration| be a new [=/service worker registration=] whose [=service worker registration/scope url=] is set to |scope| and [=service worker registration/update via cache mode=] is set to |updateViaCache|.
      1. [=map/Set=] <a>scope to registration map</a>[|scopeString|] to |registration|.
      1. Return |registration|.
  </section>

  <section algorithm>
    <h3 id="clear-registration-algorithm"><dfn>Clear Registration</dfn></h3>

      : Input
      :: |registration|, a [=/service worker registration=]
      : Output
      :: None

      1. Run the following steps atomically.
      1. If |registration|'s <a>installing worker</a> is not null, then:
          1. [=Terminate Service Worker|Terminate=] |registration|'s [=installing worker=].
          1. Run the <a>Update Worker State</a> algorithm passing |registration|'s [=installing worker=] and "`redundant`" as the arguments.
          1. Run the <a>Update Registration State</a> algorithm passing |registration|, "<code>installing</code>" and null as the arguments.
      1. If |registration|'s <a>waiting worker</a> is not null, then:
          1. [=Terminate Service Worker|Terminate=] |registration|'s [=waiting worker=].
          1. Run the <a>Update Worker State</a> algorithm passing |registration|'s [=waiting worker=] and "`redundant`" as the arguments.
          1. Run the <a>Update Registration State</a> algorithm passing |registration|, "<code>waiting</code>" and null as the arguments.
      1. If |registration|'s <a>active worker</a> is not null, then:
          1. [=Terminate Service Worker|Terminate=] |registration|'s [=active worker=].
          1. Run the <a>Update Worker State</a> algorithm passing |registration|'s [=active worker=] and "`redundant`" as the arguments.
          1. Run the <a>Update Registration State</a> algorithm passing |registration|, "<code>active</code>" and null as the arguments.
  </section>

  <section algorithm>
    <h3 id="try-clear-registration-algorithm"><dfn>Try Clear Registration</dfn></h3>

      : Input
      :: |registration|, a [=/service worker registration=]
      : Output
      :: None

      1. Invoke [=Clear Registration=] with |registration| if no [=/service worker client=] is [=using=] |registration| and all of the following conditions are true:
          * |registration|'s [=installing worker=] is null or the result of running [=Service Worker Has No Pending Events=] with |registration|’s [=installing worker=] is true.
          * |registration|'s [=waiting worker=] is null or the result of running [=Service Worker Has No Pending Events=] with |registration|’s [=waiting worker=] is true.
          * |registration|'s [=active worker=] is null or the result of running [=Service Worker Has No Pending Events=] with |registration|’s [=active worker=] is true.
  </section>

  <section algorithm>
    <h3 id="update-registration-state-algorithm"><dfn>Update Registration State</dfn></h3>

      : Input
      :: |registration|, a [=/service worker registration=]
      :: |target|, a string (one of "`installing`", "`waiting`", and "`active`")
      :: |source|, a [=/service worker=] or null
      : Output
      :: None

      1. Let |registrationObjects| be an array containing all the {{ServiceWorkerRegistration}} objects associated with |registration|.
      1. If |target| is "`installing`", then:
          1. Set |registration|'s [=installing worker=] to |source|.
          1. For each |registrationObject| in |registrationObjects|:
              1. [=Queue a task=] to set the {{ServiceWorkerRegistration/installing}} attribute of |registrationObject| to null if |registration|’s [=installing worker=] is null, or the result of [=getting the service worker object=] that represents |registration|’s [=installing worker=] in |registrationObject|'s [=relevant settings object=].
      1. Else if |target| is "`waiting`", then:
          1. Set |registration|'s [=waiting worker=] to |source|.
          1. For each |registrationObject| in |registrationObjects|:
              1. [=Queue a task=] to set the {{ServiceWorkerRegistration/waiting}} attribute of |registrationObject| to null if |registration|’s [=waiting worker=] is null, or the result of [=getting the service worker object=] that represents |registration|’s [=waiting worker=] in |registrationObject|'s [=relevant settings object=].
      1. Else if |target| is "`active`", then:
          1. Set |registration|'s [=service worker registration/active worker=] to |source|.
          1. For each |registrationObject| in |registrationObjects|:
              1. [=Queue a task=] to set the {{ServiceWorkerRegistration/active}} attribute of |registrationObject| to null if |registration|’s [=active worker=] is null, or the result of [=getting the service worker object=] that represents |registration|’s [=active worker=] in |registrationObject|'s [=relevant settings object=].

        The [=task=] *must* use |registrationObject|'s [=relevant settings object=]'s [=responsible event loop=] and the [=DOM manipulation task source=].
  </section>

  <section algorithm>
    <h3 id="update-state-algorithm"><dfn>Update Worker State</dfn></h3>

      : Input
      :: |worker|, a [=/service worker=]
      :: |state|, a [=/service worker=] [=service worker/state=]
      : Output
      :: None

      1. Assert: |state| is not "`parsed`".

          Note: "`parsed`" is the initial state. A [=/service worker=] is never updated to this state.

      1. Set |worker|'s [=service worker/state=] to |state|.
      1. Let |settingsObjects| be all [=environment settings objects=] whose [=environment settings object/origin=] is |worker|'s [=service worker/script url=]'s [=url/origin=].
      1. For each |settingsObject| of |settingsObjects|, [=queue a task=] on |settingsObject|'s [=responsible event loop=] in the [=DOM manipulation task source=] to run the following steps:
          1. Let |objectMap| be |settingsObject|'s [=environment settings object/service worker object map=].
          1. If |objectMap|[|worker|] does not [=map/exist=], then abort these steps.
          1. Let |workerObj| be |objectMap|[|worker|].
          1. Set |workerObj|'s {{ServiceWorker/state}} to |state|.
          1. [=Fire an event=] named {{statechange!!event}} at |workerObj|.
  </section>

  <section algorithm>
    <h3 id="notify-controller-change-algorithm"><dfn>Notify Controller Change</dfn></h3>

      : Input
      :: |client|, a [=/service worker client=]
      : Output
      :: None

      1. Assert: |client| is not null.
      1. If |client| is an [=environment settings object=], <a>queue a task</a> to [=fire an event=] named <code>controllerchange</code> at the {{ServiceWorkerContainer}} object that |client| is [=ServiceWorkerContainer/service worker client|associated=] with.

    The <a>task</a> *must* use |client|'s <a>responsible event loop</a> and the <a>DOM manipulation task source</a>.
  </section>

  <section algorithm>
    <h3 id="scope-match-algorithm"><dfn export>Match Service Worker Registration</dfn></h3>

      : Input
      :: |clientURL|, a [=/URL=]
      : Output
      :: A [=/service worker registration=]

      1. Run the following steps atomically.
      1. Let |clientURLString| be <a lt="URL serializer">serialized</a> |clientURL|.
      1. Let |matchingScopeString| be the empty string.
      1. Let |scopeStringSet| be the result of [=map/get the keys|getting the keys=] from <a>scope to registration map</a>.
      1. Set |matchingScopeString| to the longest value in |scopeStringSet| which the value of |clientURLString| starts with, if it exists.

          Note: The URL string matching in this step is prefix-based rather than path-structural. E.g. a client URL string with "https://example.com/prefix-of/resource.html" will match a registration for a scope with "https://example.com/prefix". The URL string comparison is safe for the same-origin security as HTTP(S) URLs are always [=URL serializer|serialized=] with a trailing slash at the end of the origin part of the URLs.

      1. Let |matchingScope| be null.
      1. If |matchingScopeString| is not the empty string, then:
          1. Set |matchingScope| to the result of <a lt="URL parser">parsing</a> |matchingScopeString|.
          1. Assert: |matchingScope|'s [=url/origin=] and |clientURL|'s [=url/origin=] are [=same origin=].
      1. Return the result of running [=Get Registration=] algorithm passing |matchingScope| as the argument.
  </section>

  <section algorithm>
    <h3 id="get-registration-algorithm"><dfn>Get Registration</dfn></h3>

      : Input
      :: |scope|, a [=/URL=]
      : Output
      :: A [=/service worker registration=]

      1. Run the following steps atomically.
      1. Let |scopeString| be the empty string.
      1. If |scope| is not null, set |scopeString| to [=URL serializer|serialized=] |scope| with the *exclude fragment flag* set.
      1. [=map/For each=] |key| → |value| of <a>scope to registration map</a>:
          1. If |scopeString| matches |key|, then return |value|.
      1. Return null.
  </section>

  <section algorithm>
    <h3 id="get-newest-worker-algorithm"><dfn>Get Newest Worker</dfn></h3>

      : Input
      :: |registration|, a [=/service worker registration=]
      : Output
      :: |newestWorker|, a [=/service worker=]

      1. Run the following steps atomically.
      1. Let |newestWorker| be null.
      1. If |registration|'s <a>installing worker</a> is not null, set |newestWorker| to |registration|'s <a>installing worker</a>.
      1. Else if |registration|'s <a>waiting worker</a> is not null, set |newestWorker| to |registration|'s <a>waiting worker</a>.
      1. Else if |registration|'s <a>active worker</a> is not null, set |newestWorker| to |registration|'s <a>active worker</a>.
      1. Return |newestWorker|.
  </section>

  <section algorithm>
    <h3 id="service-worker-has-no-pending-events-algorithm"><dfn>Service Worker Has No Pending Events</dfn></h3>

      : Input
      :: |worker|, a [=/service worker=]
      : Output
      :: True or false, a boolean

      1. For each |event| of |worker|'s [=set of extended events=]:
          1. If |event| is [=ExtendableEvent/active=], return false.
      1. Return true.
  </section>

  <section algorithm>
    <h3 id="create-client-algorithm"><dfn>Create Client</dfn></h3>

      : Input
      :: |client|, a [=/service worker client=]
      : Output
      :: |clientObject|, a {{Client}} object

      1. Let |clientObject| be a new {{Client}} object.
      1. Set |clientObject|'s [=Client/service worker client=] to |client|.
      1. Return |clientObject|.
  </section>

  <section algorithm>
    <h3 id="create-windowclient-algorithm"><dfn>Create Window Client</dfn></h3>

      : Input
      :: |client|, a [=/service worker client=]
      :: |frameType|, a string
      :: |visibilityState|, a string
      :: |focusState|, a boolean
      :: |ancestorOriginsList|, a list
      : Output
      :: |windowClient|, a {{WindowClient}} object

      1. Let |windowClient| be a new {{WindowClient}} object.
      1. Set |windowClient|'s [=Client/service worker client=] to |client|.
      1. Set |windowClient|'s [=frame type=] to |frameType|.
      1. Set |windowClient|'s [=visibility state=] to |visibilityState|.
      1. Set |windowClient|'s [=focus state=] to |focusState|.
      1. Set |windowClient|'s [=WindowClient/ancestor origins array=] to a [=frozen array type|frozen array=] created from |ancestorOriginsList|.
      1. Return |windowClient|.
  </section>

  <section algorithm>
    <h3 id="get-frametype-algorithm"><dfn>Get Frame Type</dfn></h3>

      : Input
      :: |browsingContext|, a [=/browsing context=]
      : Output
      :: <var ignore="">frameType</var>, a string

      1. Return the value by switching on the type of |browsingContext|:
          : [=Nested browsing context=]
          :: "nested"

          : [=Auxiliary browsing context=]
          :: "auxiliary"

          : Otherwise
          :: "top-level"
  </section>

  <section algorithm>
    <h3 id="resolve-get-client-promise-algorithm"><dfn>Resolve Get Client Promise</dfn></h3>

      : Input
      :: |client|, a [=/service worker client=]
      :: |promise|, a [=promise=]

      : Output
      :: none

      1. If |client| is an [=environment settings object=], then:
          1. If |client| is not a [=secure context=], [=queue a task=] to reject |promise| with a "{{SecurityError}}" {{DOMException}}, on |promise|'s [=relevant settings object=]'s [=responsible event loop=] using the [=DOM manipulation task source=], and abort these steps.
      1. Else:
          1. If |client|’s [=creation URL=] is not a [=potentially trustworthy URL=], [=queue a task=] to reject |promise| with a "{{SecurityError}}" {{DOMException}}, on |promise|'s [=relevant settings object=]'s [=responsible event loop=] using the [=DOM manipulation task source=], and abort these steps.
      1. If |client| is an [=environment settings object=] and is not a [=window client=], then:
          1. Let |clientObject| be the result of running [=Create Client=] algorithm with |client| as the argument.
          1. [=Queue a task=] to resolve |promise| with |clientObject|, on |promise|'s [=relevant settings object=]'s [=responsible event loop=] using the [=DOM manipulation task source=], and abort these steps.
      1. Else:
          1. Let |browsingContext| be null.
          1. If |client| is an [=environment settings object=], set |browsingContext| to |client|'s [=environment settings object/global object=]'s [=/browsing context=].
          1. Else, set |browsingContext| to |client|’s [=environment/target browsing context=].
          1. [=Queue a task=] to run the following steps on |browsingContext|'s [=event loop=] using the [=user interaction task source=]:
              1. Let |frameType| be the result of running [=Get Frame Type=] with |browsingContext|.
              1. Let |visibilityState| be |browsingContext|'s [=active document=]'s {{Document/visibilityState}} attribute value.
              1. Let |focusState| be the result of running the [=has focus steps=] with |browsingContext|'s [=active document=] as the argument.
              1. Let |ancestorOriginsList| be the empty list.
              1. If |client| is a [=window client=], set |ancestorOriginsList| to |browsingContext|'s [=active document=]'s [=relevant global object=]'s {{Location}} object's [=Location/ancestor origins list=]'s associated list.
              1. [=Queue a task=] to run the following steps on |promise|'s [=relevant settings object=]'s [=responsible event loop=] using the [=DOM manipulation task source=]:
                  1. If |client|'s [=discarded flag=] is set, resolve |promise| with undefined and abort these steps.
                  1. Let |windowClient| be the result of running [=Create Window Client=] with |client|, |frameType|, |visibilityState|, |focusState|, and |ancestorOriginsList|.
                  1. Resolve |promise| with |windowClient|.
  </section>

  <section algorithm>
    <h3 id="query-cache-algorithm"><dfn>Query Cache</dfn></h3>

      : Input
      :: |requestQuery|, a [=/request=]
      :: |options|, a {{CacheQueryOptions}} object, optional
      :: |targetStorage|, a [=request response list=], optional
      : Output
      :: |resultList|, a [=request response list=]

      1. Let |resultList| be an empty [=list=].
      1. Let |storage| be null.
      1. If the optional argument |targetStorage| is omitted, set |storage| to the [=relevant request response list=].
      1. Else, set |storage| to |targetStorage|.
      1. [=list/For each=] |requestResponse| of |storage|:
          1. Let |cachedRequest| be |requestResponse|'s request.
          1. Let |cachedResponse| be |requestResponse|'s response.
          1. If [=Request Matches Cached Item=] with |requestQuery|, |cachedRequest|, |cachedResponse|, and |options| returns true, then:
            1. Let |requestCopy| be a copy of |cachedRequest|.
            1. Let |responseCopy| be a copy of |cachedResponse|.
            1. Add |requestCopy|/|responseCopy| to |resultList|.
      1. Return |resultList|.
  </section>

  <section algorithm>
    <h3 id="request-matches-cached-item-algorithm"><dfn export>Request Matches Cached Item</dfn></h3>

      : Input
      :: |requestQuery|, a [=/request=]
      :: |request|, a [=/request=]
      :: |response|, a [=/response=] or null, optional, defaulting to null
      :: |options|, a {{CacheQueryOptions}} object, optional
      : Output
      :: a boolean

      1. If |options|["{{CacheQueryOptions/ignoreMethod}}"] is false and |request|'s [=request/method=] is not \``GET`\`, return false.
      1. Let |queryURL| be |requestQuery|'s [=request/url=].
      1. Let |cachedURL| be |request|'s [=request/url=].
      1. If |options|["{{CacheQueryOptions/ignoreSearch}}"] is true, then:
          1. Set |cachedURL|'s [=url/query=] to the empty string.
          1. Set |queryURL|'s [=url/query=] to the empty string.
      1. If |queryURL| does not [=url/equal=] |cachedURL| with the *exclude fragment flag* set, then return false.
      1. If |response| is null, |options|["{{CacheQueryOptions/ignoreVary}}"] is true, or |response|'s [=response/header list=] does not [=header list/contain=] \``Vary`\`, then return true.
      1. Let |fieldValues| be the [=list=] containing the elements corresponding to the [=http/field-values=] of the [=Vary=] header for the [=header/value=] of the [=header=] with [=header/name=] \``Vary`\`.
      1. For each |fieldValue| in |fieldValues|:
          1. If |fieldValue| matches "`*`", or the [=header list/combine|combined value=] given |fieldValue| and |request|'s [=request/header list=] does not match the [=header list/combine|combined value=] given |fieldValue| and |requestQuery|'s [=request/header list=], then return false.
      1. Return true.
  </section>

  <section algorithm>
    <h3 id="batch-cache-operations-algorithm"><dfn>Batch Cache Operations</dfn></h3>

      : Input
      :: |operations|, a [=list=] of [=cache batch operation=] objects
      : Output
      :: |resultList|, a [=request response list=]

      1. Let |cache| be the [=relevant request response list=].
      1. Let |backupCache| be a new [=request response list=] that is a copy of |cache|.
      1. Let |addedItems| be an empty [=list=].
      1. Try running the following substeps atomically:
          1. Let |resultList| be an empty [=list=].
          1. [=list/For each=] |operation| in |operations|:
              1. If |operation|'s [=cache batch operation/type=] matches neither "`delete`" nor "`put`", <a>throw</a> a <code>TypeError</code>.
              1. If |operation|'s [=cache batch operation/type=] matches "`delete`" and |operation|'s [=cache batch operation/response=] is not null, <a>throw</a> a <code>TypeError</code>.
              1. If the result of running [=Query Cache=] with |operation|'s [=cache batch operation/request=], |operation|'s [=cache batch operation/options=], and |addedItems| [=list/is not empty=], [=throw=] an "{{InvalidStateError}}" {{DOMException}}.
              1. Let |requestResponses| be an empty [=list=].
              1. If |operation|'s [=cache batch operation/type=] matches "`delete`", then:
                  1. Set |requestResponses| to the result of running [=Query Cache=] with |operation|'s [=cache batch operation/request=] and |operation|'s [=cache batch operation/options=].
                  1. [=list/For each=] |requestResponse| in |requestResponses|:
                      1. [=list/Remove=] the [=list/item=] whose value matches |requestResponse| from |cache|.
              1. Else if |operation|'s [=cache batch operation/type=] matches "`put`", then:
                  1. If |operation|'s [=cache batch operation/response=] is null, <a>throw</a> a <code>TypeError</code>.
                  1. Let |r| be |operation|'s [=cache batch operation/request=]'s associated [=Request/request=].
                  1. If |r|'s [=request/url=]'s [=url/scheme=] is not one of "<code>http</code>" and "<code>https</code>", <a>throw</a> a <code>TypeError</code>.
                  1. If |r|'s [=request/method=] is not \`<code>GET</code>\`, <a>throw</a> a <code>TypeError</code>.
                  1. If |operation|'s [=cache batch operation/options=] is not null, <a>throw</a> a <code>TypeError</code>.
                  1. Set |requestResponses| to the result of running [=Query Cache=] with |operation|'s [=cache batch operation/request=].
                  1. [=list/For each=] |requestResponse| of |requestResponses|:
                      1. [=list/Remove=] the [=list/item=] whose value matches |requestResponse| from |cache|.
                  1. [=list/Append=] |operation|'s [=cache batch operation/request=]/|operation|'s [=cache batch operation/response=] to |cache|.
                  1. If the cache write operation in the previous two steps failed due to exceeding the granted quota limit, <a>throw</a> a "{{QuotaExceededError}}" {{DOMException}}.
                  1. [=list/Append=] |operation|'s [=cache batch operation/request=]/|operation|'s [=cache batch operation/response=] to |addedItems|.
              1. [=Append=] |operation|'s [=cache batch operation/request=]/|operation|'s [=cache batch operation/response=] to |resultList|.
          1. Return |resultList|.
      1. And then, if an exception was <a lt="throw">thrown</a>, then:
          1. [=list/Remove=] all the [=list/items=] from the [=relevant request response list=].
          1. [=list/For each=] |requestResponse| of |backupCache|:
            1. [=list/Append=] |requestResponse| to the [=relevant request response list=].
          1. [=Throw=] the exception.

          Note: When an exception is [=throw|thrown=], the implementation does undo (roll back) any changes made to the cache storage during the batch operation job.
  </section>

  <section algorithm>
    <h3 id="is-async-module-algorithm"><dfn>Is Async Module</dfn></h3>

      : Input
      :: |record|, a [=Module Record=]
      :: |moduleMap|, a [=/module map=]
      :: |base|, a [=/URL=]
      :: |seen|, a [=/set=] of [=/URLs=]
      : Output
      :: a boolean

      1. If |record| is not a [=Cyclic Module Record=], then:
          1. Return false.
      1. If |record|.\[[Async]] is true, then:
          1. Return true.
      1. [=list/For each=] string |requested| of |record|.\[[RequestedModules]]:
          1. Let |url| be the result of [=resolve a module specifier|resolving a module specifier=] given |base| and |requested|.
          1. Assert: |url| is never failure, because [=resolve a module specifier|resolving a module specifier=] must have been previously successful with these same two arguments.
          1. If |seen| does not [=set/contain=] |url|, then:
              1. [=set/Append=] |url| to |seen|.
              1. If |moduleMap|[|url|] does not have a [=script/record=], then:
                  1. Return false.
              1. If [=Is Async Module=] for |moduleMap|[|url|]'s [=script/record=], |moduleMap|, |base|, and |seen| is true, then:
                  1. Return true.
      1. Return false.
  </section>
</section>

<section>
  <h2 id="extended-http-headers">Appendix B: Extended HTTP headers</h2>

  <section>
    <h3 id="service-worker-script-request">Service Worker Script Request</h3>

    An HTTP request to [=/fetch=] a [=/service worker=]'s <a>script resource</a> will include the following <a>header</a>:

      : \`<dfn><code>Service-Worker</code></dfn>\`
      :: Indicates this request is a [=/service worker=]'s <a>script resource</a> request.

        Note: This header helps administrators log the requests and detect threats.
  </section>

  <section>
    <h3 id="service-worker-script-response">Service Worker Script Response</h3>

    An HTTP response to a [=/service worker=]'s <a>script resource</a> request can include the following <a>header</a>:

      : \`<dfn><code>Service-Worker-Allowed</code></dfn>\`
      :: Indicates the user agent will override the path restriction, which limits the maximum allowed [=service worker registration/scope url=] that the script can <a>control</a>, to the given value.

        Note: The value is a URL. If a relative URL is given, it is parsed against the script's URL.

    <div class="example">
      Default scope:

      <pre highlight="js">
        // Maximum allowed scope defaults to the path the script sits in
        // "/js/" in this example
        navigator.serviceWorker.register("/js/sw.js").then(() => {
          console.log("Install succeeded with the default scope '/js/'.");
        });
      </pre>
    </div>

    <div class="example">
      Upper path without Service-Worker-Allowed header:

      <pre highlight="js">
        // Set the scope to an upper path of the script location
        // Response has no Service-Worker-Allowed header
        navigator.serviceWorker.register("/js/sw.js", { scope: "/" }).catch(() => {
          console.error("Install failed due to the path restriction violation.");
        });
      </pre>
    </div>

    <div class="example">
      Upper path with Service-Worker-Allowed header:

      <pre highlight="js">
        // Set the scope to an upper path of the script location
        // Response included "Service-Worker-Allowed : /"
        navigator.serviceWorker.register("/js/sw.js", { scope: "/" }).then(() => {
          console.log("Install succeeded as the max allowed scope was overriden to '/'.");
        });
      </pre>
    </div>

    <div class="example">
      A path restriction voliation even with Service-Worker-Allowed header:

      <pre highlight="js">
        // Set the scope to an upper path of the script location
        // Response included "Service-Worker-Allowed : /foo"
        navigator.serviceWorker.register("/foo/bar/sw.js", { scope: "/" }).catch(() => {
          console.error("Install failed as the scope is still out of the overriden maximum allowed scope.");
        });
      </pre>
    </div>
  </section>

  <section>
    <h3 id="syntax">Syntax</h3>

    <a biblio data-biblio-type="normative" lt="rfc5234">ABNF</a> for the values of the headers used by the [=/service worker=]'s <a>script resource</a> requests and responses:

    <pre>
      Service-Worker = %x73.63.72.69.70.74 ; "script", case-sensitive
    </pre>

    Note: The validation of the Service-Worker-Allowed header's values is done by URL parsing algorithm (in Update algorithm) instead of using ABNF.
  </section>
</section>

<section>
  <h2 id="acknowledgements">Acknowledgements</h2>
  <!-- FIXME: INCOMPLETE!! Please add collaborators below. -->

  Deep thanks go to Andrew Betts for organizing and hosting a small workshop of like-minded individuals including: Jake Archibald, Jackson Gabbard, Tobie Langel, Robin Berjon, Patrick Lauke, Christian Heilmann. From the clarity of the day's discussions and the use-cases outlined there, much has become possible. Further thanks to Andrew for raising consciousness about the offline problem. His organization of EdgeConf and inclusion of Offline as a persistent topic there has created many opportunities and connections that have enabled this work to progress.

  Anne van Kesteren has generously lent his encyclopedic knowledge of Web Platform arcana and standards development experience throughout the development of the service worker. This specification would be incomplete without his previous work in describing the real-world behavior of URLs, HTTP Fetch, Promises, and DOM. Similarly, this specification would not be possible without Ian Hickson's rigorous Web Worker spec. Much thanks to him.

  In no particular order, deep gratitude for design guidance and discussion goes to: Jungkee Song, Alec Flett, David Barrett-Kahn, Aaron Boodman, Michael Nordman, Tom Ashworth, Kinuko Yasuda, Darin Fisher, Jonas Sicking, Jesús Leganés Combarro, Mark Christian, Dave Hermann, Yehuda Katz, François Remy, Ilya Grigorik, Will Chan, Domenic Denicola, Nikhil Marathe, Yves Lafon, Adam Barth, Greg Simon, Devdatta Akhawe, Dominic Cooney, Jeffrey Yasskin, Joshua Bell, Boris Zbarsky, Matt Falkenhagen, Tobie Langel, Gavin Peters, Ben Kelly, Hiroki Nakagawa, Jake Archibald, Josh Soref, Jinho Bang, Yutaka Hirano, Michael(tm) Smith, isonmad, Ali Alabbas, Philip Jägenstedt, Mike Pennisi, and Eric Willigers.

  Jason Weber, Chris Wilson, Paul Kinlan, Ehsan Akhgari, and Daniel Austin have provided valuable, well-timed feedback on requirements and the standardization process.

  The authors would also like to thank Dimitri Glazkov for his scripts and formatting tools which have been essential in the production of this specification. The authors are also grateful for his considerable guidance.

  Thanks also to Vivian Cromwell, Greg Simon, Alex Komoroske, Wonsuk Lee, and Seojin Kim for their considerable professional support.
</section>
