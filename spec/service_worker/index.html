<!DOCTYPE html>
<html lang="en">
<head>
<title>Service Workers</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<link rel="stylesheet" href="../assets/styles/main.css" type="text/css">
<link rel="stylesheet" href="../assets/styles/spec.css" type="text/css">
<link rel="stylesheet" href="../assets/styles/prettify.css" type="text/css">
<link rel="stylesheet" href="../assets/styles/third_party/W3C-ED.css" type="text/css" >
<script src="../assets/scripts/bug-assist.js"></script>
<script src="../assets/scripts/spec-assist.js"></script>
<script src="../assets/scripts/prettify.js"></script>
<!-- <meta name="bug.blocked" content="14968"> -->
<meta name="bug.short_desc" content="[ServiceWorker]: ">
<meta name="bug.product" content="WebAppsWG">
<meta name="bug.component" content="ServiceWorker">
</head>

<body>

<div class="head">

<div class="logo">
    <a href="//www.w3.org/"><img width="72" height="48" src="//www.w3.org/Icons/w3c_home" alt="W3C"></a>
</div>

<h1>Service Workers</h1>
<h2 id="editors-draft">W3C Editor's Draft</h2>
<dl>
<dt>This version</dt>
    <dd><a href="https://github.com/slightlyoff/ServiceWorker/tree/master/spec/service_worker/index.html">https://github.com/slightlyoff/ServiceWorker/tree/master/spec/service_worker/index.html</a></dd>
<dt>Latest editor's draft</dt>
    <dd><a href="https://github.com/slightlyoff/ServiceWorker/tree/master/spec/service_worker/index.html">https://github.com/slightlyoff/ServiceWorker/tree/master/spec/service_worker/index.html</a></dd>
<dt>Previous version</dt>
    <dd><a href="http://www.w3.org/TR/service-workers/">http://www.w3.org/TR/service-workers/</a></dd>
<dt>Revision history</dt>
    <dd><a id="log" href="https://github.com/slightlyoff/ServiceWorker/commits/master">https://github.com/slightlyoff/ServiceWorker/commits/master</a></dd>
<dt>Participate</dt>
    <dd>Discuss on <a href="http://lists.w3.org/Archives/Public/public-webapps/">public-webapps@w3.org</a> (<a href="http://www.w3.org/2008/webapps/">Web Applications Working Group</a>)</dd>
    <dd><a href="https://www.w3.org/Bugs/Public/enter_bug.cgi?comment=&amp;blocked=14968&amp;short_desc=%5BCustom%5D%3A%20&amp;product=WebAppsWG&amp;component=Component%20Model">File bugs</a> (w3.org's <a href="https://www.w3.org/Bugs/Public/">Bugzilla</a>)</dd>
<dt>Editors</dt>
    <dd class="vcard"><span class="fn">Alex Russell</span>, <span class="org">Google</span>, &lt;<a class="email" href="mailto:slightlyoff@chromium.org">slightlyoff@chromium.org</a>&gt;</dd>
    <dd class="vcard"><span class="fn">Jungkee Song</span>, <span class="org">Samsung Electronics</span>, &lt;<a class="email" href="mailto:slightlyoff@chromium.org">jungkee.song@samsung.com</a>&gt;</dd>
</dl>

<p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> &copy; 2014 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>&copy;</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. <abbr title="World Wide Web Consortium">W3C</abbr> <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>

<hr>

<h2 id="abstract">Abstract</h2>

<p>This specification describes a method that enables applications to take advantage of persistent background processing, including hooks to enable bootstrapping of web applications while offline.</p>

<p>The core of this system is an event-driven <a href="http://www.w3.org/TR/workers/">Web Worker</a> which responds to events dispatched from documents and other sources. A system for managing installation, versions, upgrades is provided.</p>

<p>The Service Worker is a generic entry point for event-driven background processing in the Web Platform that is <a href="#extensibility">extensible by other specifications</a>.</p>

<h2 id="status">Status of This Document</h2>

<p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current <abbr title="World Wide Web Consortium">W3C</abbr> publications and the latest revision of this technical report can be found in the <a href="http://www.w3.org/TR/"><abbr title="World Wide Web Consortium">W3C</abbr> technical reports index</a> at http://www.w3.org/TR/.</em></p>

<p>This document was published by the <a href="http://www.w3.org/2008/webapps/">Web Applications Working Group</a> as an Editor's Draft. If you wish to make comments regarding this document, please send them to <a href="mailto:public-webapps@w3.org">public-webapps@w3.org</a> (<a href="mailto:public-webapps-request@w3.org?subject=subscribe">subscribe</a>, <a href="http://lists.w3.org/Archives/Public/public-webapps/">archives</a>). All feedback is welcome.</p><p>Publication as an Editor's Draft does not imply endorsement by the <abbr title="World Wide Web Consortium">W3C</abbr> Membership. This is a draft document and may be updated, replaced or obsoleted by other documents at any time. It is inappropriate to cite this document as other than work in progress.</p>

<p>This document was produced by a group operating under the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 <abbr title="World Wide Web Consortium">W3C</abbr> Patent Policy</a>. <abbr title="World Wide Web Consortium">W3C</abbr> maintains a <a href="http://www.w3.org/2004/01/pp-impl/45559/status" rel="disclosure">public list of any patent disclosures</a> made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential Claim(s)</a> must disclose the information in accordance with <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 6 of the <abbr title="World Wide Web Consortium">W3C</abbr> Patent Policy</a>.</p>

</div>

<section class="toc">
<h2 id="toc">Table of Contents</h2>
<ol>
    <li><a href="#introduction">Introduction</a>
    <ol>
        <li><a href="#about">About this Document</a></li>
        <li><a href="#dependencies">Dependencies</a></li>
        <li><a href="#motivations">Motivations</a></li>
        <li><a href="#concepts">Concepts</a></li>
        <li><a href="#offline-example">Example: Offline Web Applications</a></li>
    </ol></li>

    <li><a href="#service-worker-lifecycle">Service Worker Lifecycle</a>
    <ol>
        <li><a href="#registration">Registration</a></li>
        <li><a href="#event-handling">Event Handling</a></li>
        <li><a href="#installation">Installation</a>
            <ol><li><a href="#worker-script-caching">Worker Script Caching</a></li></ol>
        </li>
        <li><a href="#activation">Activation</a></li>
        <li><a href="#navigation-matching">Navigation Matching</a>
        <li><a href="#fetch-handling">Fetch Handling</a>
        <li><a href="#lifetime-extension">Lifetime Extension</a></li>
        <li><a href="#upgrade">Upgrade</a></li>
    </ol></li>

    <li><a href="#document-context">Document Context</a>
    <ol>
        <li><a href="#service-worker"><code>ServiceWorker</code></a></li>
        <li><a href="#navigator-service-worker"><code>navigator.serviceWorker</code></a>
        <ol>
            <li><a href="#navigator-service-worker-active"><code>active</code></a></li>
            <li><a href="#navigator-service-worker-getAll"><code>getAll()</code></a></li>
            <li><a href="#navigator-service-worker-register"><code>register()</code></a></li>
            <li><a href="#navigator-service-worker-unregister"><code>unregister()</code></a></li>
            <li><a href="#navigator-service-worker-oninstall"><code>oninstall</code></a></li>
            <li><a href="#navigator-service-worker-oninstallend"><code>oninstallend</code></a></li>
            <li><a href="#navigator-service-worker-onactivate"><code>onactivate</code></a></li>
            <li><a href="#navigator-service-worker-onactivateend"><code>onactivateend</code></a></li>
            <li><a href="#navigator-service-worker-onreloadpage"><code>onreloadpage</code></a></li>
            <li><a href="#navigator-service-worker-onerror"><code>onerror</code></a></li>
        </ol></li>
    </ol></li>

    <li><a href="#execution-context">Execution Context</a>
    <ol>
        <li><a href="#service-worker-global-scope"><code>ServiceWorkerGlobalScope</code></a>
        <ol>
            <li><a href="#service-worker-global-scope-caches"><code>caches</code></a></li>
            <li><a href="#service-worker-global-scope-clients"><code>clients</code></a></li>
            <li><a href="#service-worker-global-scope-scope"><code>scope</code></a></li>
            <li><a href="#service-worker-global-scope-fetch"><code>fetch(request)</code></a></li>
            <li><a href="#service-worker-global-scope-update"><code>update()</code></a></li>
            <li><a href="#service-worker-global-scope-unregister"><code>unregister()</code></a></li>
            <li><a href="#service-worker-global-scope-onmessage"><code>onmessage</code></a></li>
        </ol></li>
        <li><a href="#request-objects"><code>Request</code> Objects</a></li>
        <li><a href="#response-objects"><code>Response</code> Objects</a>
        <ol>
            <li><a href="#abstract-response"><code>AbstractResponse</code></a></li>
            <li><a href="#response"><code>Response</code></a></li>
            <li><a href="#opaque-response"><code>OpaqueResponse</code></a></li>
            <li><a href="#cors-response"><code>CORSResponse</code></a></li>
        </ol>
        </li>
        <li><a href="#fetch"><code>fetch()</code></a></li>
        <li><a href="#cache-objects">Caches</a>
        <ol>
            <li><a href="#cache-lifetimes">Cache Lifetime Semantics</a></li>
            <li><a href="#cache"><code>Cache</code></a></li>
            <li><a href="#async-map"><code>AsyncMap</code></a></li>
            <li><a href="#cache-list"><code>CacheList</code></a></li>
        </ol>
        </li>
        <li><a href="#client"><code>Client</code></a>
            <ol><li><a href="#service-worker-clients"><code>ServiceWorkerClients</code></a></li></ol>
        </li>
        <li><a href="#events">Events</a>
        <ol>
            <li><a href="#install-phase-event"><code>InstallPhaseEvent</code></a></li>
            <li><a href="#oninstall"><code>oninstall</code></a>
                <ol><li><a href="#install-event"><code>InstallEvent</code></a></li></ol>
            </li>
            <li><a href="#onactivate"><code>onactivate</code></a>
                <ol><li><a href="#activate-event"><code>ActivateEvent</code></a></li></ol>
            </li>
            <li><a href="#onfetch"><code>onfetch</code></a>
                <ol><li><a href="#fetch-event"><code>FetchEvent</code></a></li></ol>
            </li>
        </ol></li>
    </ol></li>

    <li><a href="#security-considerations">Security Considerations</a>
    <ol>
        <li><a href="#origin-relativity">Origin Relativity</a></li>
        <li><a href="#x-origin-resources">Cross-Origin Resources & CORS</a></li>
    </ol></li>
    <li><a href="#storage-considerations">Storage Considerations</a></li>
    <li><a href="#extensibility">Extensibility</a></li>
    <li><a href="#appendix-a">Appendix A: Algorithms</a></li>
    <li><a href="#acknowledgements" class="no-number">Acknowledgements</a></li>

</ol>

</section>

<section class="spec">

<h2 id="introduction">Introduction</h2>

<h3 id="about">About this Document</h3>

<p>All diagrams, examples, notes, are non-normative, as well as sections explicitly marked as non-normative. Everything else in this specification is normative.</p>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in the normative parts of this document are to be interpreted as described in <a href="http://dev.w3.org/2006/xbl2/#refsRFC2119">RFC2119</a>. For readability, these words do not appear in all uppercase letters in this specification.</p>

<p>Any point, at which a conforming UA must make decisions about the state or reaction to the state of the conceptual model, is captured as <a href="http://en.wikipedia.org/wiki/Algorithm">algorithm</a>. The algorithms are defined in terms of processing equivalence. The <dfn id="dfn-processing-equivalence">processing equivalence</dfn> is a constraint imposed on the algorithm implementors, requiring the output of the both UA-implemented and the specified algorithm to be exactly the same for all inputs.</p>

<h3 id="dependencies">Dependencies</h3>

<p>This document relies on the following specifications:</p>

<ul>
    <li><a href="http://www.w3.org/TR/workers/">Web Workers</a></li>
    <li><a href="http://fetch.spec.whatwg.org/">Fetch Living Standard</a></li>
    <li><a href="http://dom.spec.whatwg.org/">DOM Living Standard</a></li>
    <li><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/">HTML Living Standard</a></li>
    <li><a href="http://ecma-international.org/ecma-262/5.1/">ECMAScript Language Specification</a></li>
    <li><a href="http://www.w3.org/TR/WebIDL/">Web IDL</a></li>
    <li><a href="http://www.w3.org/TR/IndexedDB/">Indexed DB</a></li>
    <li><a href="http://www.w3.org/TR/quota-api/">Quota Management API</a></li>
    <li><a href="http://www.w3.org/TR/notifications/">Web Notifications</a></li>
</ul>

<h3 id="motivations">Motivations</h3>

<div class="informative">
<p>Web Applications traditionally assume that the network is reachable. This assumption pervades the platform. HTML documents are loaded over HTTP and traditionally fetch all of their sub-resources via subsequent HTTP requests. This places web content at a disadvantage versus other technology stacks.<p>

<p>The Service Worker is designed first to redress this balance by providing a Web Worker context which can be started by a runtime when navigations are about to occur. This event-driven worker is registered against an origin and a path (or pattern), meaning it can be consulted when navigations occur to that location. Events that correspond to network requests are dispatched to the worker and the responses generated by the worker may over-ride default network stack behavior. This puts the Service Worker, conceptually, between the network and a document renderer, allowing the Service Worker to provide content for documents, even while offline.</p>

<p>Web developers familiar with previous attempts to solve the offline problem have reported a deficit of flexibility in those solutions. As a result, the Service Worker is highly proceedural, providing a maximum of flexibility at the price of additional complexity for developers. Part of this complexity arises from the need to keep Service Workers responsive in the face of a single-threaded execution model. As a result, APIs exposed by Service Workers are almost entirely asynchronous, a pattern familiar in other JavaScript contexts but accentuated here by the need to avoid blocking document and resource loading.</p>

<p>Developers using the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/offline.html">HTML5 Application Cache</a> have also <a href="http://alistapart.com/article/application-cache-is-a-douchebag">reported that several attributes</a> of the design contribute to <a href="http://alistapart.com/article/application-cache-is-a-douchebag#section6">unrecoverable errors</a>. A key design principle of the Service Worker is that errors should <em>always</em> be recoverable. Many details of the update process of Service Workers are designed to avoid these hazards.</p>

<p>Service Workers are started and kept alive by their relationship to events, not documents. This design borrows heavily from developer and vendor experience with <a href="http://www.w3.org/TR/workers/#sharedworker">Shared Workers</a> and <a href="http://developer.chrome.com/extensions/background_pages.html">Chrome Background Pages</a>. A key lesson from these systems is the necessity to time-limit the execution of background processing contexts, both to conserve resources and to ensure that background context loss and restart is top-of-mind for developers. As a result, Service Workers bear more than a passing resemblence to <a href="http://developer.chrome.com/extensions/event_pages.html">Chrome Event Pages</a>, the successor to Background Pages. Service Workers may be started by user agents <em>without an attached document</em> and may be killed by the user agent at nearly any time. Conceptually, Service Workers can be thought of as Shared Workers that can start, process events, and die without ever handling messages from documents. Developers are advised to keep in mind that Service Workers may be started and killed many times a second.</p>

<p>Service Workers are generic, event-driven, time-limited script contexts that run at an origin. These properties make them natural endpoints for a range of runtime services that may outlive the context of a particular doucment, e.g. handling push notifications, background data synchronization, responding to resource requests from other origins, or receiving centralized updates to expensive-to-calculate data (e.g., geolocation or gyroscope).</p>
</div>

<h3 id="concepts">Concepts</h3>

<p>A <a id="#service-worker">Service Worker</a> is a type of <a href="http://www.w3.org/TR/workers/">Web Worker</a>. Unlike other Worker variants, the lifetime of a Service Worker is tied to events, not references to documents.</p>

<p>Service Workers are <a href="#installation">installed</a> by user agents after being <a href="#registration">registered</a> by authors from the context of a <a href="http://dom.spec.whatwg.org/#concept-document">document</a>. Service Workers execute in the registering document's <a href="#FIXME">origin</a>.</p>

<p>Installation of a Service Worker proceeds through several phases:</p>

<ol>
    <li><em>Fetch</em>:
    <br>
    The script URL provided by the author (via a call to <a href="#register-service-worker"><code>navigator.serviceWorker.register([script URL], [registration option])</code></a> from a document) is fetched without <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.2.2">heuristic caching</a>. If the return status code of the fetch is not <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2">2xx</a>, installation aborts.</li>
    <li><em>Startup</em>:
    <br>
    If fetching the worker script is successful, it is <a href="http://www.w3.org/TR/workers/#processing-model">executed</a> in a <code><a href="#service-worker-global-scope">ServiceWorkerGlobalScope</a></code>. These scripts may call <code><a href="http://www.w3.org/TR/workers/#importing-scripts-and-libraries">importScripts</a></code> resulting in further fetches. Imported scripts are fetched, <a href="https://people.mozilla.org/~jorendorff/es5.1-final.html#sec-5.1.4">parsed</a> and <a href="https://people.mozilla.org/~jorendorff/es5.1-final.html#sec-10.4.1">executed</a> in turn, per the ECMA-262 and <a href="http://www.w3.org/TR/workers/#importing-scripts-and-libraries">Web Worker specifications</a>. All resources downloaded as part of the very first startup of a Service Worker are cached along with the worker script as described in <a href="#worker-script-caching">"Worker Script Caching"</a>.
    </li>
    <li><em><code>oninstall</code></em>:
    <br>
    Once a Service Worker has been fetched and started, it is ready to process <a href="http://dom.spec.whatwg.org/#interface-event">events</a>. The first event sent to every Service Worker is <a href="#oninstall"><code>oninstall</code></a>. Workers that handle this event are encouraged to use it as a way to prime the available storage mechanisms for supporting offline application use; perhaps by populating <a href="http://www.w3.org/TR/IndexedDB/">IndexedDB databases</a> or <a href="#cache-objects"><code>Cache</code> objects</a>.
    <br>
    <br>
    Service Workers are not considered "installed" until the <code>oninstall</code> event completes. Given that many tasks, such as populating caches, may take a long time and are asynchronous, <a href="#lifetime-extension">mechanisms are provided</a> to let applications signal to the user agent when they consider themselves perpared to handle futher events.
    <br>
    <br>
    If no <code>oninstall</code> event handler is registered, the Service Worker is considered to be successfully installed.
    <br>
    <br>
    If any <code>oninstall</code> handler throws an exception, or if any lifetime extension via <code>e.waitUntil()</code> fails (via Promise rejection), installation fails and activation is not carried out.
    </li>
    <li><em><code>onactivate</code></em>:
    <br>
    After successful installation and just prior to receiving functional events (e.g., <code><a href="#onfetch">onfetch</a></code>), the <code>onactivate</code> event is dispatched. Like <code>oninstall</code>, this event may extend its lifetime using <code>e.waitUntil()</code>, however developers should note that activation is particularly performance sensitive. It is likely that performance sensitive events are blocking on its successful completion.
    <br>
    <br>
    The primary use of <code>onactivate</code> is for cleanup of resources used in previous versions of a Service Worker script.
    <br>
    <br>
    </li>
</ol>
<p>
Once <code>onactivate</code> succeeds, and only then, may the user agent dispatch events which correspond to application logic; for example <code><a href="#onfetch">onfetch</a></code> for deciding the dispostion of network requests.
</p>
<!--
<div class="informative">
<p>...</p>
</div>
 -->
 <h3 id="offline-example">Example: Offline Web Applications</h3>

<pre><code class="prettyprint">
// TODO(slightlyoff)
</code></pre>

<h2 id="service-worker-lifecycle">Service Worker Lifecycle</h2>

...

<h3 id="registration">Registration</h3>

...

<h3 id="event-handling">Event Handling</h3>

...

<h3 id="installation">Installation</h3>

...

<h4 id="worker-script-caching">Worker Script Caching</h4>

...

<h3 id="activation">Activation</h3>

...

<h3 id="navigation-matching">Navigation Matching</h3>

...

<h3 id="fetch-handling">Fetch Handling</h3>

...

<h3 id="lifetime-extension">Lifetime Extension</h3>

...

<h3 id="upgrade">Upgrade</h3>

...

<h2 id="document-context">Document Context</h2>

<h3 id="service-worker"><code>ServiceWorker</code></h3>

<p></p>
<pre><code>[Constructor()] // no-op constructor
interface <dfn id="service-worker-interface" title="ServiceWorker">ServiceWorker</dfn> : <a href="http://goo.gl/mkHcfY">Worker</a> {
  readonly attribute DOMString scope;
  readonly attribute DOMString url;

  // event
    attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> ondeactivate;
};</code></pre>

<p>The <code>SerivceWorker</code> interface represents the document-side view of a Service Worker. This object provides a no-op constructor. Callers should note that only <code>ServiceWorker</code> objects created by the user agent (see <a href="#navigator-service-worker-active"><code>navigator.serviceWorker.active</code></a>) will provide meaningful functionality.</p>

<p>The <code>scope</code> of a <code>ServiceWorker</code> reflects the scope of the <code>ServiceWorker</code>'s <a href="#registration">registration</a>. For example, consider a document created by a navigation to <code>http://example.com/app.html</code> which <a href="#navigation-matching">matches</a> via the following registration call which has been previously executed:</p>

<pre><code class="prettyprint">// Script on the page http://example.com/app.html
navigator.serviceWorker.register("/service_worker.js", { scope: "*" });</code></pre>

<p>The value of <code>navigator.serviceWorker.active.scope</code> will be <code>"*"</code>.</p>

<p>Similarly, in this example, the value of <code>navigator.serviceWorker.active.url</code> will be <code>"http://example.com/service_worker.js"</code>. The <code>url</code> property is always an <a href="http://url.spec.whatwg.org/#concept-absolute-url">absolute URL</a> corresponding to the script file which the Service Worker evaluates.</p>

<p>The <code>ondeactivate</code> event is fired in a turn following <a href="#replace-method">replacment</a> of the <code>ServiceWorker</code>.</p>

<h3 id="navigator-service-worker"><code>navigator.serviceWorker</code></h3>

<p><code>navigator.serviceWorker</code> is an object which provides access to registration, removal, upgrade, and communication with service workers that are (or will become) active for the current document.</p>

<p>The <code>active</code> property of this object provides a reference to the service worker which was consulted during the construction of the current document (if any).</p>

<p>Communication with these workers is provided via standard <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/web-messaging.html">HTML5 messaging APIs</a>, and <a href="http://www.w3.org/TR/workers/#dom-worker-postmessage">messaging occurs as per usual with Web Workers</a>.</p>

<pre><code>partial interface <a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#navigator-0">Navigator</a> {
  readonly attribute <a href="#navigator-service-worker-interface">NavigatorServiceWorker</a> serviceWorker;
};

interface <dfn id="navigator-service-worker-interface" title="NavigatorServiceWorker">NavigatorServiceWorker</dfn> {
  [<a href="http://heycam.github.io/webidl/#Unforgeable">Unforgeable</a>] readonly attribute <a href="#service-worker-interface">ServiceWorker</a>? active;

  <a href="http://goo.gl/3TobQS">Promise</a> getAll(); // Promise for Array&lt;ServiceWorker&gt;
  <a href="http://goo.gl/3TobQS">Promise</a> register(DOMString <var>url</var>, optional <a href="#registration-option-list-dictionary">RegistrationOptionList</a> <var>options</var>);
  <a href="http://goo.gl/3TobQS">Promise</a> unregister(DOMString? <var>scope</var>);

  // events
    attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> oninstall;
    attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> oninstallend;
    attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> onactivate;
    attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> onactivateend;
    attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> onreloadpage;
    attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> onerror;
};

dictionary <dfn id="registration-option-list-dictionary" title="RegistrationOptionList">RegistrationOptionList</dfn> {
  DOMString scope = "/*";
};

interface <dfn id="reload-page-event-interface" title="ReloadPageEvent">ReloadPageEvent</dfn> : <a href="http://goo.gl/UVs0Yt">Event</a> {
  void waitUntil(<a href="http://goo.gl/3TobQS">Promise</a> <var>f</var>);
};

interface <dfn id="document-install-phase-event-interface" title="DocumentInstallPhaseEvent">DocumentInstallPhaseEvent</dfn> : <a href="http://goo.gl/UVs0Yt">Event</a> {
  readonly attribute <a href="#service-worker-interface">ServiceWorker</a> worker;
};

interface <dfn id="document-install-event-interface" title="DocumentInstallEvent">DocumentInstallEvent</dfn> : <a href="#document-install-phase-event-interface">DocumentInstallPhaseEvent</a> {
  readonly attribute <a href="#service-worker-interface">ServiceWorker</a> previous;
};
</code></pre>

<h4 id="navigator-service-worker-active"><code>active</code></h4>

<p><code>navigator.serviceWorker.active</code> provides a reference to the <a href="#service-worker"><code>SerivceWorker</code></a></p>

<p><code>navigator.serviceWorker.active</code> is <code>null</code> if the current document was not <a href="#navigation-matching">created under a service worker</a>.</p>


<h4 id="navigator-service-worker-getAll"><code>getAll()</code></h4>
<h4 id="navigator-service-worker-register"><code>register()</code></h4>
<h4 id="navigator-service-worker-unregister"><code>unregister()</code></h4>
<h4 id="navigator-service-worker-oninstall"><code>oninstall</code></h4>
<h4 id="navigator-service-worker-oninstallend"><code>oninstallend</code></h4>
<h4 id="navigator-service-worker-onactivate"><code>onactivate</code></h4>
<h4 id="navigator-service-worker-onactivateend"><code>onactivateend</code></h4>
<h4 id="navigator-service-worker-onreloadpage"><code>onreloadpage</code></h4>
<h4 id="navigator-service-worker-onerror"><code>onerror</code></h4>

<h2 id="execution-context">Execution Context</h2>

<h3 id="service-worker-global-scope"><code>ServiceWorkerGlobalScope</code></h3>

<pre><code>[<a href="http://heycam.github.io/webidl/#Global">Global</a>]
interface <dfn id="service-worker-global-scope-interface" title="ServiceWorkerGlobalScope">ServiceWorkerGlobalScope</dfn> : <a href="http://goo.gl/mkHcfYglobalscope">WorkerGlobalScope</a> {
  readonly attribute <a href="#cache-list-interface">CacheList</a> caches;
  // A container for a list of window objects, identifiable by ID, that
  // correspond to windows (or workers) that are "controlled" by this SW
  readonly attribute <a href="#service-worker-clients-interface">ServiceWorkerClients</a> clients;
  [<a href="http://heycam.github.io/webidl/#Unforgeable">Unforgeable</a>] readonly attribute DOMString scope;

  <a href="#response-promise-interface">ResponsePromise</a> fetch((<a href="#request-interface">Request</a> or [<a href="http://goo.gl/VdmjMo">EnsureUTF16</a>] <a href="http://goo.gl/Kxbl8E">URL</a> or DOMString) <var>request</var>);

  // Ping the server for an updated version of this script, without consulting
  // caches. Conceptually the same operation that SW's do max once every 24
  // hours.
  void update();
  void unregister();

    attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> oninstall;
    attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> onactivate;
    attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> onfetch;
    attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> onbeforeevicted;
    attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> onevicted;

    // The event.source of these MessageEvents are instances of Client
    attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> onmessage;

  // close() method inherited from WorkerGlobalScope is not exposed.
};
</code></pre>

<p>The <code>ServiceWorkerGlobalScope</code> interface represents the global execution context of a Service Worker. <code>ServiceWorkerGlobalScope</code> object provides generic, event-driven, time-limited script execution contexts that run at an origin. Once successfully <a href="#registration">register</a>ed, a Service Worker is started, kept alive and killed by their relationship to events, not documents. Any type of synchronous requests MUST NOT be initiated inside of a Service Worker.</p>

<h4 id="service-worker-global-scope-caches"><code>caches</code></h4>
<h4 id="service-worker-global-scope-clients"><code>clients</code></h4>
<h4 id="service-worker-global-scope-scope"><code>scope</code></h4>
<h4 id="service-worker-global-scope-fetch"><code>fetch(request)</code></h4>
<h4 id="service-worker-global-scope-update"><code>update()</code></h4>
<h4 id="service-worker-global-scope-unregister"><code>unregister()</code></h4>
<h4 id="service-worker-global-scope-onmessage"><code>onmessage</code></h4>

<h3 id="request-objects"><code>Request</code> Objects</h3>

<pre><code>
interface <dfn id="request-promise-interface" title="RequestPromise">RequestPromise</dfn> : <a href="http://goo.gl/3TobQS">Promise</a> {
};

[Constructor(optional <a href="#request-init-dictionary">RequestInit</a> <var>init</var>)]
interface <dfn id="request-interface" title="Request">Request</dfn> {
  attribute unsigned long timeout;
  attribute DOMString url;
  attribute <a href="http://goo.gl/M46tpy">ByteString</a> method;
  readonly attribute DOMString origin;
  readonly attribute <a href="#mode-dictionary">Mode</a> mode;
  attribute boolean synchronous;
  readonly attribute unsigned long redirectCount;
  attribute boolean forcePreflight;
  attribute boolean omitCredentials;
  readonly attribute <a href="http://goo.gl/Kxbl8E">URL</a> referrer;
  readonly attribute <a href="#header-map-interface">HeaderMap</a> headers; // alternative: sequence&lt;Header&gt; headers;
  attribute any body;
};

dictionary <dfn id="request-init-dictionary" title="RequestInit">RequestInit</dfn> {
  unsigned long timeout = 0;
  DOMString url;
  boolean synchronous = false;
  boolean forcePreflight = false;
  boolean omitCredentials = false;
  <a href="http://goo.gl/M46tpy">ByteString</a> method = "GET";
  <a href="#header-map-interface">HeaderMap</a> headers;
  any body;
};

enum <dfn id="mode-enum" title="Mode">Mode</dfn> {
  "same origin",
  "tainted x-origin",
  "CORS"
};

[<a href="http://goo.gl/lJQaAt">MapClass</a>(DOMString, DOMString)]
interface <dfn id="header-map-interface" title="HeaderMap">HeaderMap</dfn> {
};
</code></pre>

<h3 id="response-objects"><code>Response</code> Objects</h3>

<code>Resposne</code> objects model HTTP responses.


<code>Response</code>

<pre><code>
interface <dfn id="response-promise-interface" title="ResponsePromise">ResponsePromise</dfn> : <a href="http://goo.gl/3TobQS">Promise</a> {
  <a href="http://goo.gl/3TobQS">Promise</a> toBlob();
};

[Constructor]
interface <dfn id="abstract-response-interface" title="AbstractResponse">AbstractResponse</dfn> {
};

[Constructor(optional <a href="#response-init-dictionary">ResponseInit</a> <var>responseInitDict</var>)]
interface <dfn id="response-interface" title="Response">Response</dfn> : <a href="#abstract-response-interface">AbstractResponse</a> {
  attribute unsigned short statusCode;
  attribute <a href="http://goo.gl/M46tpy">ByteString</a> statusText;
  attribute <a href="http://goo.gl/M46tpy">ByteString</a> method;
  getter <a href="#header-map-interface">HeaderMap</a> headers();
  setter void headers(<a href="#header-map-interface">HeaderMap</a> items);
  DOMString url;
  <a href="http://goo.gl/3TobQS">Promise</a> toBlob();
};

dictionary <dfn id="response-init-dictionary" title="ResponseInit">ResponseInit</dfn> {
  unsigned short statusCode = 200;
  <a href="http://goo.gl/M46tpy">ByteString</a> statusText = "OK";
  <a href="http://goo.gl/M46tpy">ByteString</a> method;
  <a href="#header-map-interface">HeaderMap</a> headers;
};

interface <dfn id="opaque-response-interface" title="OpaqueResponse">OpaqueResponse</dfn> : <a href="#abstract-response-interface">AbstractResponse</a> {
  getter DOMString url();
};

interface <dfn id="cors-response-interface" title="CORSResponse">CORSResponse</dfn> : <a href="#response-interface">Response</a> {
  // TODO: slightlyoff: make CORS headers readable but not setable?
  // TODO: outline the whitelist of readable headers
};
</code></pre>

<h4 id="abstract-response"><code>AbstractResponse</code></h4>

<code>AbstractResponse</code> is an abstract superclass for all Resposne types. It should not be directly constructed (although, for compatibility with JavaScript, a constructor is provided).

<h4 id="response"><code>Response</code></h4>

<code>Response</code> objects are mutable, constructable <code>Response</code>s. The <code>headers</code>, <code>body</code>, and other attributes may be set directly in script.

Note that while it may be possible to set the <code>Location</code> header of a <code>Response</code> object to someplace not in the current origin, this is not a security issue. Since no cross-origin response bodies are immutable and opaque to script, and since only same-origin documents will encounter these responses, the only systems the Service Worker can "lie to" are same-origin (and therefore safe from the perspective of other origins).

<h4 id="opaque-response"><code>OpaqueResponse</code></h4>

...

<h4 id="cors-response"><code>CORSResponse</code></h4>

...

<h3 id="fetch"><code>fetch()</code></h3>

...

<h3 id="cache-objects">Caches</h3>

...

<h4 id="cache-lifetimes">Understanding Cache Lifetimes</h4>

...

<h4 id="cache"><code>Cache</code></h4>

<pre><code>
[Constructor((<a href="http://goo.gl/Kxbl8E">URL</a> or [<a href="http://goo.gl/VdmjMo">EnsureUTF16</a>] DOMString)... <var>urls</var>)]
interface <dfn id="cache-interface" title="Cache">Cache</dfn> {
  readonly attribute <a href="#async-map-interface">AsyncMap</a> items;

  <a href="http://goo.gl/3TobQS">Promise</a> match((<a href="http://goo.gl/Kxbl8E">URL</a> or [<a href="http://goo.gl/VdmjMo">EnsureUTF16</a>] DOMString) <var>name</var>);
  <a href="http://goo.gl/3TobQS">Promise</a> add((<a href="http://goo.gl/Kxbl8E">URL</a> or [<a href="http://goo.gl/VdmjMo">EnsureUTF16</a>] DOMString)... <var>responses</var>);
  <a href="http://goo.gl/3TobQS">Promise</a> addResponse((<a href="http://goo.gl/Kxbl8E">URL</a> or [<a href="http://goo.gl/VdmjMo">EnsureUTF16</a>] DOMString) <var>url</var>, <a href="#response-interface">Response</a> <var>response</var>);
  <a href="http://goo.gl/3TobQS">Promise</a> remove((<a href="http://goo.gl/Kxbl8E">URL</a> or [<a href="http://goo.gl/VdmjMo">EnsureUTF16</a>] DOMString)... <var>responses</var>);
  <a href="http://goo.gl/3TobQS">Promise</a> update((<a href="http://goo.gl/Kxbl8E">URL</a> or [<a href="http://goo.gl/VdmjMo">EnsureUTF16</a>] DOMString)... <var>urls</var>);
  <a href="http://goo.gl/3TobQS">Promise</a> ready();
};
</code></pre>

<h4 id="async-map"><code>AsyncMap</code></h4>

<pre><code>
[<a href="http://goo.gl/lJQaAt">MapClass</a>(DOMString, <a href="#response-interface">Response</a>)]
interface <dfn id="async-map-interface" title="AsyncMap">AsyncMap</dfn> {
  <a href="http://goo.gl/3TobQS">Promise</a> get(DOMString <var>key</var>);
  <a href="http://goo.gl/3TobQS">Promise</a> has(DOMString <var>key</var>);
  <a href="http://goo.gl/3TobQS">Promise</a> set(DOMString <var>key</var>, <a href="#response-interface">Response</a> <var>val</var>);
  <a href="http://goo.gl/3TobQS">Promise</a> clear();
  <a href="http://goo.gl/3TobQS">Promise</a> delete(DOMString <var>key</var>);
  <a href="http://goo.gl/3TobQS">Promise</a> items();
  <a href="http://goo.gl/3TobQS">Promise</a> keys();
  <a href="http://goo.gl/3TobQS">Promise</a> values();
};
</code></pre>

<p><span class="fixme"><strong>Issue</strong>: the following issues should be addressed in the WebIDL specification: the methods <code>keys()</code> and <code>values()</code> are not allowed to be declared as interface members of an interface declared with the [<a class="external" href="http://goo.gl/lJQaAt">MapClass</a>] extended attribute; the return type of <code>get(key)</code>, <code>has(key)</code>, <code>set(key, val)</code>, <code>clear()</code>, <code>delete(key)</code> is meant to be declared as pre-defined IDL fragment. Namely, the interface declared with [<a class="external" href="http://goo.gl/lJQaAt">MapClass</a>] extended attribute cannot fully support creating asynchronous map objects.</span></p>

<h4 id="cache-list"><code>CacheList</code></h4>

<pre><code>
[<a href="http://goo.gl/lJQaAt">MapClass</a>(DOMString, <a href="#cache-interface">Cache</a>)]
interface <dfn id="cache-list-interface" title="CacheList">CacheList</dfn> {
  <a href="#response-promise-interface">ResponsePromise</a> match(DOMString <var>name</var>, (<a href="http://goo.gl/Kxbl8E">URL</a> or [<a href="http://goo.gl/VdmjMo">EnsureUTF16</a>] DOMString) <var>url</var>);
  <a href="http://goo.gl/3TobQS">Promise</a> get(DOMString <var>key</var>);
  <a href="http://goo.gl/3TobQS">Promise</a> has(DOMString <var>key</var>);
  <a href="http://goo.gl/3TobQS">Promise</a> set(DOMString <var>key</var>, <a href="#cache-interface">Cache</a> <var>val</var>);
  <a href="http://goo.gl/3TobQS">Promise</a> clear();
  <a href="#cache-list-interface">CacheList</a> items();
  DOMString[] keys();
  <a href="#cache-interface">Cache</a>[] values();
  getter unsinged long size();
};
</code></pre>

<h3 id="client"><code>Client</code></h3>

<pre><code>[Constructor()] // no-op constructor
interface <dfn id="client-interface" title="Client">Client</dfn> {
  readonly attribute unsigned long id;
  void postMessage(any <var>message</var>, DOMString <var>targetOrigin</var>,
                   optional sequence&lt;<a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/common-dom-interfaces.html#transferable">Transferable</a>&gt; <var>transfer</var>);
};
</code></pre>

<p>The <code>Client</code> interface represents the window or the worker (defined as client) that is controlled by the Service Worker. This object provides a no-op constructor. Callers should note that only <code>Client</code> objects created by the user agent (see <a href="#FIXME"><code>this.clients.getServiced()</code></a>) will provide meaningful functionality.</p>

<p>The <code>id</code> of a <code>Client</code> identifies the specific client object from the list of client objects serviced by the Service Worker. The <code>postMessage(message, targetOrigin, transfer)</code> method of a <code><a href="#client-interface">Client</a></code>, when called, causes a <code><a href="#FIXME">MessageEvent</a></code> to be dispatched at the client object.</p>

<h4 id="service-worker-clients"><code>ServiceWorkerClients</code></h4>

<pre><code>interface <dfn id="service-worker-clients-interface" title="ServiceWorkerClients">ServiceWorkerClients</dfn> {
  // A list of client objects, identifiable by ID, that correspond to windows
  // (or workers) that are "controlled" by this SW
  <a href="http://goo.gl/3TobQS">Promise</a> getServiced(); // Promise for Array&lt;Client&gt;
};
</code></pre>

<p>The <code>ServiceWorkerClients</code> interface represents a container for a list of <code><a href="#client-interface">Client</a></code> objects. The <code>getServiced()</code> method of a <code>ServiceWorkerClients</code>, when called, returns a <a href="http://goo.gl/3TobQS">Promise</a> that will resolve with a list of <code><a href="#client-interface">Client</a></code> objects that are controlled by this Service Worker.</p>

<h3 id="events">Events</h3>

...

<h4 id="install-phase-event"><code>InstallPhaseEvent</code></h4>

<pre><code>
interface <dfn id="install-phase-event-interface" title="InstallPhaseEvent">InstallPhaseEvent</dfn> : <a href="http://goo.gl/UVs0Yt">Event</a> {
  <a href="http://goo.gl/3TobQS">Promise</a> waitUntil(<a href="http://goo.gl/3TobQS">Promise</a> <var>f</var>);
};
</code></pre>

<h4 id="oninstall"><code>oninstall</code></h4>

...

<h5 id="install-event"><code>InstallEvent</code></h5>

<pre><code>
interface <dfn id="install-event-interface" title="InstallEvent">InstallEvent</dfn> : <a href="#install-phase-event-interface">InstallPhaseEvent</a> {
  readonly attribute <a href="#service-worker-interface">ServiceWorker</a> activeWorker;
  void replace();
  <a href="http://goo.gl/3TobQS">Promise</a> reloadAll();
};
</code></pre>

<h5 id="replace-method"><code>event.replace()</code></h5>
<p>This interacts with <code>waitUntil</code> method in the following way:</p>
<ul>
  <li>Replacement only happens upon successful installation</li>
  <li>Successful installation can be delayed by <code>waitUntil</code>, perhaps by subsequent event handlers.</li>
  <li>Therefore, replace does not happen immediately.</li>
</ul>

<h4 id="onactivate"><code>onactivate</code></h4>

...

<h5 id="activate-event"><code>ActivateEvent</code></h5>

...

<h4 id="onfetch"><code>onfetch</code></h4>

...

<h5 id="fetch-event"><code>FetchEvent</code></h5>

<pre><code>
[Constructor]
interface <dfn id="fetch-event-interface" title="FetchEvent">FetchEvent</dfn> : <a href="http://goo.gl/UVs0Yt">Event</a> {
  readonly attribute <a href="#request-interface">Request</a> request;
  readonly attribute Client client; // The window issuing the request.
  readonly attribute <a href="#purpose-enum">Purpose</a> purpose;
  readonly attribute boolean isReload;

  void respondWith((<a href="http://goo.gl/3TobQS">Promise</a> or <a href="#response-interface">Response</a>) <var>r</var>);
  <a href="http://goo.gl/3TobQS">Promise</a> forwardTo((<a href="http://goo.gl/Kxbl8E">URL</a> or [<a href="http://goo.gl/VdmjMo">EnsureUTF16</a>] DOMString) <var>url</var>);
};

enum <dfn id="purpose-enum" title="Purpose">Purpose</dfn> {
    "connect",
    "font",
    "img",
    "object",
    "script",
    "style",
    "worker",
    "popup",
    "child",
    "navigate"
};
</code></pre>

<h5 id="respond-with-method"><code>event.respondWith(r)</code></h5>
<p>If a <a href="http://goo.gl/3TobQS">Promise</a> is provided, it must resolve with a <a href="#response-interface">Response</a>, else a <a href="http://w3c.github.io/dom/#networkerror">NetworkError</a> is thrown. If the request is a top level navigation and the return value is a <a href="#opaque-response-interface">OpaqueResponse</a> (an opaque response body), a <a href="http://w3c.github.io/dom/#networkerror">NetworkError</a> is thrown. The final URL of all successful (non network-error) responses is the <a href="#request-objects">request</a>ed URL. Renderer-side security checks about tainting for x-origin content are tied to the transparency (or opacity) of the <a href="#response-interface">Response</a> body, not URLs.</p>

<h5 id="is-reload-attribute"><code>event.isReload</code></h5>
<p>Returns true if <var>event</var> was disptached with the user's intention for the page reload, and false otherwise. Pressing the refresh button should be considered a reload while clicking a link and pressing the back button should not. The behavior of the <var>Ctrl+l enter</var> is left to the implementations of the user agents.</p>

<h2 id="security-considerations">Security Considerations</h2>

...

<h3 id="origin-relativity">Origin Relativity</h3>

...

<h3 id="x-origin-resources">Cross-Origin Resources & CORS</h3>

...


<h2 id="storage-considerations">Storage Considerations</h2>

...

<h2 id="extensibility">Extensibility</h2>

...


<h2 id="appendix-a">Appendix A: Algorithms</h2>

<h3 id="registration-algorithm">Registration</h3>

<p>The <a href="#registration-algorithm">Service Worker Registration Algorithm</a> creates or updates a <a href="#FIXME">registration</a> for some amount of <a href="#FIXME">url space</a>. If successful, a registration ties the provided <a href="#FIXME">script</a> to an <a href="#FIXME">origin</a> + <a href="#FIXME">scope</a> pair which is subsequently consulted by the user for <a href="#navigation-matching-algorithm">navigation matching</a>.</p>

<!--
<div class="informative">
<p>The following pseudo-code outlines the algorithm somewhat more tersely than the long-form prose steps outlined below. Functions whose names begin with "_" are not defined and are intended to operate in the obvious way with regards to their linked algorithms.</p>

<pre><code class="prettyprint">
navigator.serviceWorker.register = function(url, options) {
    var currentURL = new URL(window.location, document.baseURI);
    var outcome = new Promise()
}
</code></pre>
</div>
 -->

<div class="algorithm">
<dl>
<dt>Input</dt>
    <dd><var>SCRIPT</var>, the URL of the script to register; a string</dd>
    <dd><var>ORIGIN</var>, the origin of the registering document</dd>
    <dd><var>SCOPE</var>, a string representing a <a href="#FIXME">relative URL pattern</a></dd>
<dt>Output</dt>
    <dd>OUTCOME, a <a href="http://goo.gl/3TobQS">Promise</a> whose resolution indicates the success or failure of the algorithm</dd>
</dl>
<ol>
    <li>Let <var></var> be the result of </li>
    <li>If <var>CALLBACK</var> exists and is a <a href="http://es5.github.io/#callable">callable object</a>, add <var>CALLBACK</var> to <var>LIFECYCLE</var>, associated with the key <var>NAME</var>.</li>

<!--
The steps are:
    * check the script URL for same-origin-ness with the current document
        * if x-origin, reject and return
        * if same-origin, continue
    * fetch the script with the force same-origin flag set (see: http://www.whatwg.org/specs/web-apps/current-work/multipage/fetching-resources.html#fetch)
        * if the last update from the server occured more than 24 hours ago, fetch the script with cache-busting headers
        * if the response isn't success, reject and return
    * if the script is successfully fetched, start the worker (per http://www.whatwg.org/specs/web-apps/current-work/multipage/workers.html#processing-model-7, steps 5 and 6)
        * if any error is encountered, reject and return
    * fire the "oninstall" event on the SW and on navigator.serviceWorker for all documents which most specifically match origin+scope
        * if an exception is thrown by any handler, reject and set the installenderror flag
        * if any handler calls waitUntil, extend the install process until they all resolve.
            * if any extension handlers are rejected, reject and set the installenderror flag
            * if all extension handlers resolve successfully, resolve succesfully
        * if no extension handlers are registered, resolve successfully
    * fire "oninstallend" against naavigator.serviceWorker in all documents which most-specifically match origin+scope
        * FIXME: what to do about the event object in the case of errors here?
    * if the installenderror flag is true:
        * dispatch onerror against navigator.serviceWorker in all documents which most specifically match origin+scope
        * return and exit
    * set the "workerinwaiting" flag on the installed worker and run the check-worker-in-waiting algorithm
<script>

</script>
 -->
<!--
     <li>Let <var>PROTOTYPE</var> be the <a href="#dfn-custom-element-prototype">custom element prototype</a> in <var>ELEMENT</var>'s <a href="#dfn-element-definition">definition</a></li>
    <li>Set the value of the <code>[[Prototype]]</code> <a href="http://es5.github.io/#x8.6.2">internal property</a> of <var>ELEMENT</var> to <var>PROTOTYPE</var>.</li>
    <li>If <var>ELEMENT</var> is <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/infrastructure.html#in-a-document">in a document</a> and this <a href="http://dom.spec.whatwg.org/#concept-document">document</a> has a <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html#browsing-context">browsing context</a>:
    <ol>
        <li><a href="#dfn-enqueue-lifecycle-callback">Enqueue</a> <a href="#dfn-entered-view-callback"><em>enteredView</em></a> callback for <var>ELEMENT</var></li>
    </ol></li>
 -->
</ol>
</div>

<h3 id="installation-algorithm">Installation</h3>

<h3 id="update-algorithm">Update</h3>

<h3 id="replacement-algorithm">Replacement</h3>

<h3 id="navigation-matching-algorithm">Navigation Matching</h3>

<h3 id="unregistration-algorithm">Unregistration</h3>

</section>

<!-- FIXME: INCOMPLETE!! Please add collaborators below. -->
<h2 id="acknowledgements">Acknowledgements</h2>

<p>Jake Archibald is a ghost-author of this document. The best instincts in the design are his. He similarly shaped many of the details through discussion and experimentation. The bits which are not his (but which are good) owe everything to his experience, persistence, and focus on enabling web developers. He embodies a hopeful example for developers in shaping browser efforts to more directly address real-world pain points. If Service Workers solve "offline for the web", the credit is due him.</p>

<p>Deep thanks go to Andrew Betts for organizing and hosting a small workshop of like-minded individuals including: Jake Archibald, Jackson Gabbard, Tobie Langel, Robin Berjon, Patrick Lauke, Christian Heilmann. From the clarity of the day's discussions and the use-cases outlined there, much has become possible. Further thanks to Andrew for raising consciousness about the offline problem. His organization of EdgeConf and inclusion of Offline as a persistent topic there has created many opportunities and connections that have enabled this work to progress.</p>

<p>Anne van Kesteren has generously lent his encyclopedic knowledge of Web Platform arcana and standards development experience throught the development of the Service Worker. This specification would be incomplete without his previous work in describing the real-world behavior of URLs, HTTP Fetch, Promises, and DOM. Similarly, this specification would not be possible without Ian Hickson's rigorous Web Worker spec. Much thanks to him.</p>

<p>In no particular order, deep gratitude for design guidance and discussion goes to: Junkee Song, Alec Flett, David Barrett-Kahn, Aaron Boodman, Michael Nordman, Tom Ashworth, Kinuko Yasuda, Darin Fisher, Jonas Sicking, Jess Legans Combarro, Mark Christian, Dave Hermann, Yehuda Katz, Franois Remy, Ilya Grigorik, Will Chan, Domenic Denicola, Nikhil Marathe, Yves Lafon, Adam Barth, Greg Simon, and Devdatta Akhawe.</p>

<p>Jason Weber, Chris Wilson, Paul Kinlan, Ehsan Akhgari, and Daniel Austin have provided valuable, well-timed feedback on requirements and the standardization process.</p>

<p>The authors would also like to thank Dimitri Glazkov for his scripts and formatting tools which have been essential in the production of this specification. The authors are also grateful for his considerable guidance.</p>

<p>Thanks also to Vivian Cromwell, Greg Simon, and Alex Komoroske for their considerable professional support.</p>
</body>
</html>
